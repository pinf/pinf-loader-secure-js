{
  ".": {
    "bundles": {
      "/sandbox.js": {
        "modules": {
          "/sandbox.js": {
            "requireId": "/sandbox",
            "memoizeId": "/sandbox.js",
            "descriptor": {
              "filename": "sandbox.js",
              "filepath": "sandbox.js",
              "mtime": 1407997188,
              "code": "\nconst SJCL = require(\"sjcl\");\nconst ECC = require(\"./ecc\");\n\n\nexports.main = function() {\n\treturn exports;\n}\n\nexports.sandbox = function(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback) {\n\n\tif (!sandboxIdentifier) {\n\t\tif (errorCallback) return errorCallback(new Error(\"'sandboxIdentifier' not specified\"));\n\t\tthrow new Error(\"'sandboxIdentifier' not specified\");\n\t}\n\n\tif (typeof sandboxOptions === \"function\" && typeof loadedCallback === \"function\" && typeof errorCallback === \"undefined\") {\n\t\terrorCallback = loadedCallback;\n\t\tloadedCallback = sandboxOptions;\n\t\tsandboxOptions = {};\n\t} else\n\tif (typeof sandboxOptions === \"function\" && typeof loadedCallback === \"undefined\") {\n\t\tloadedCallback = sandboxOptions;\n\t\tsandboxOptions = {};\n\t} else {\n\t\tsandboxOptions = sandboxOptions || {};\n\t}\n\n\tif (typeof sandboxOptions.secure !== \"object\") {\n\t\treturn errorCallback(new Error(\"'secure' property not set!\"));\n\t}\n\tif (typeof sandboxOptions.secure.bundles !== \"object\") {\n\t\treturn errorCallback(new Error(\"'secure.bundles' property not set!\"));\n\t}\n\n\tvar signatures = {};\n\tsandboxOptions.secure.bundles.filter(function(bundle) {\n\t\treturn /^eccver:/.test(bundle) && !/^eccver:\\*$/.test(bundle);\n\t}).map(function (bundle) {\n\t\tvar key = bundle.match(/^eccver:(.{7})/)[1];\n\t\tif (!signatures[key]) {\n\t\t\tsignatures[key] = [];\n\t\t}\n\t\tsignatures[key].push(bundle);\n\t});\n\n\t// TODO: Keep track of different instances of `PINF.bundle()`\n\t//       so we can allow multiple secure sandboxes at the same time.\n\tvar _orig_bundle_handler = PINF.setActiveBundleHandler(function(uid, callback, meta) {\n\n\t\tif (!meta || typeof meta !== \"object\") {\n\t\t\tthrow new Error(\"No meta data supplied for bundle '\" + uid + \"'!\");\n\t\t}\n\n\t\tvar verified = false;\n\n\t\t// NOTE: For the following verification implementation to work,\n\t\t//       the return value of `callback.toString()` must be an\n\t\t//       EXACT copy of the source code sent to the browser\n\t\t//       by the server.\n\n\t\t// A signature is preferred but optional.\n\n\t\tif (typeof meta.signature === \"string\") {\n\t\t\tvar signatureParts = meta.signature.split(\":\");\n\t\t\tif (signatureParts[0] !== \"ecc\") {\n\t\t\t\tthrow new Error(\"Signature type '\" + signatureParts[0] + \"' used by bundle '\" + uid + \"' not supported!\");\n\t\t\t}\n\t\t\tif (signatures[signatureParts[1]]) {\n\t\t\t\tsignatures[signatureParts[1]].forEach(function (verifier) {\n\t\t\t\t\tif (verified) return;\n\t\t\t\t\tif (!/^eccver:/.test(verifier)) return;\n\t\t\t\t\tif (ECC.verify(verifier.split(\":\")[1], SJCL.codec.hex.toBits(signatureParts[2]), callback.toString())) {\n\t\t\t\t\t\tverified = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!verified) {\n\t\t\t\t\tthrow new Error(\"Bundle signature supplied for bundle '\" + uid + \"' does not match signature calculated using verifier '\" + signatureParts[1] + \"' based on toString() for bundle payload!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// A hash is required at minimum.\n\n\t\tif (!verified) {\n\n\t\t\tif (typeof meta.hash !== \"string\") {\n\t\t\t\tthrow new Error(\"No hash supplied for bundle '\" + uid + \"'!\");\n\t\t\t}\n\n\t\t\tvar hashParts = meta.hash.split(\":\");\n\t\t\tif (typeof SJCL.hash[hashParts[0]] === \"undefined\") {\n\t\t\t\tthrow new Error(\"Hash type '\" + hashParts[0] + \"' used by bundle '\" + uid + \"' not supported!\");\n\t\t\t}\n\t\t\tif (hashParts[1] !== SJCL.codec.hex.fromBits(SJCL.hash[hashParts[0]].hash(callback.toString()))) {\n\t\t\t\tthrow new Error(\"Bundle hash supplied for bundle '\" + uid + \"' does not match calculated hash from toString() of bundle payload!\");\n\t\t\t}\n\t\t\tif (sandboxOptions.secure.bundles.indexOf(meta.hash) === -1) {\n\t\t\t\tif (sandboxOptions.secure.bundles.indexOf(hashParts[0] + \":*\") === -1) {\n\t\t\t\t\tthrow new Error(\"Hash '\" + meta.hash + \"' used by bundle '\" + uid + \"' not declared in 'secure.bundles'!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn _orig_bundle_handler(uid, callback);\n\t});\n\n\treturn require.sandbox(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback);\n}\n",
              "globals": {
                "SJCL": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "ECC": {
                  "type": "assign"
                },
                "exports": {
                  "type": "reference"
                },
                "PINF": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "sjcl": {
                    "where": "inline"
                  },
                  "./ecc": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = '';",
              "code": "function(require, exports, module) {var __dirname = '';\n\nconst SJCL = require(\"sjcl\");\nconst ECC = require(\"./ecc\");\n\n\nexports.main = function() {\n\treturn exports;\n}\n\nexports.sandbox = function(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback) {\n\n\tif (!sandboxIdentifier) {\n\t\tif (errorCallback) return errorCallback(new Error(\"'sandboxIdentifier' not specified\"));\n\t\tthrow new Error(\"'sandboxIdentifier' not specified\");\n\t}\n\n\tif (typeof sandboxOptions === \"function\" && typeof loadedCallback === \"function\" && typeof errorCallback === \"undefined\") {\n\t\terrorCallback = loadedCallback;\n\t\tloadedCallback = sandboxOptions;\n\t\tsandboxOptions = {};\n\t} else\n\tif (typeof sandboxOptions === \"function\" && typeof loadedCallback === \"undefined\") {\n\t\tloadedCallback = sandboxOptions;\n\t\tsandboxOptions = {};\n\t} else {\n\t\tsandboxOptions = sandboxOptions || {};\n\t}\n\n\tif (typeof sandboxOptions.secure !== \"object\") {\n\t\treturn errorCallback(new Error(\"'secure' property not set!\"));\n\t}\n\tif (typeof sandboxOptions.secure.bundles !== \"object\") {\n\t\treturn errorCallback(new Error(\"'secure.bundles' property not set!\"));\n\t}\n\n\tvar signatures = {};\n\tsandboxOptions.secure.bundles.filter(function(bundle) {\n\t\treturn /^eccver:/.test(bundle) && !/^eccver:\\*$/.test(bundle);\n\t}).map(function (bundle) {\n\t\tvar key = bundle.match(/^eccver:(.{7})/)[1];\n\t\tif (!signatures[key]) {\n\t\t\tsignatures[key] = [];\n\t\t}\n\t\tsignatures[key].push(bundle);\n\t});\n\n\t// TODO: Keep track of different instances of `PINF.bundle()`\n\t//       so we can allow multiple secure sandboxes at the same time.\n\tvar _orig_bundle_handler = PINF.setActiveBundleHandler(function(uid, callback, meta) {\n\n\t\tif (!meta || typeof meta !== \"object\") {\n\t\t\tthrow new Error(\"No meta data supplied for bundle '\" + uid + \"'!\");\n\t\t}\n\n\t\tvar verified = false;\n\n\t\t// NOTE: For the following verification implementation to work,\n\t\t//       the return value of `callback.toString()` must be an\n\t\t//       EXACT copy of the source code sent to the browser\n\t\t//       by the server.\n\n\t\t// A signature is preferred but optional.\n\n\t\tif (typeof meta.signature === \"string\") {\n\t\t\tvar signatureParts = meta.signature.split(\":\");\n\t\t\tif (signatureParts[0] !== \"ecc\") {\n\t\t\t\tthrow new Error(\"Signature type '\" + signatureParts[0] + \"' used by bundle '\" + uid + \"' not supported!\");\n\t\t\t}\n\t\t\tif (signatures[signatureParts[1]]) {\n\t\t\t\tsignatures[signatureParts[1]].forEach(function (verifier) {\n\t\t\t\t\tif (verified) return;\n\t\t\t\t\tif (!/^eccver:/.test(verifier)) return;\n\t\t\t\t\tif (ECC.verify(verifier.split(\":\")[1], SJCL.codec.hex.toBits(signatureParts[2]), callback.toString())) {\n\t\t\t\t\t\tverified = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!verified) {\n\t\t\t\t\tthrow new Error(\"Bundle signature supplied for bundle '\" + uid + \"' does not match signature calculated using verifier '\" + signatureParts[1] + \"' based on toString() for bundle payload!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// A hash is required at minimum.\n\n\t\tif (!verified) {\n\n\t\t\tif (typeof meta.hash !== \"string\") {\n\t\t\t\tthrow new Error(\"No hash supplied for bundle '\" + uid + \"'!\");\n\t\t\t}\n\n\t\t\tvar hashParts = meta.hash.split(\":\");\n\t\t\tif (typeof SJCL.hash[hashParts[0]] === \"undefined\") {\n\t\t\t\tthrow new Error(\"Hash type '\" + hashParts[0] + \"' used by bundle '\" + uid + \"' not supported!\");\n\t\t\t}\n\t\t\tif (hashParts[1] !== SJCL.codec.hex.fromBits(SJCL.hash[hashParts[0]].hash(callback.toString()))) {\n\t\t\t\tthrow new Error(\"Bundle hash supplied for bundle '\" + uid + \"' does not match calculated hash from toString() of bundle payload!\");\n\t\t\t}\n\t\t\tif (sandboxOptions.secure.bundles.indexOf(meta.hash) === -1) {\n\t\t\t\tif (sandboxOptions.secure.bundles.indexOf(hashParts[0] + \":*\") === -1) {\n\t\t\t\t\tthrow new Error(\"Hash '\" + meta.hash + \"' used by bundle '\" + uid + \"' not declared in 'secure.bundles'!\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn _orig_bundle_handler(uid, callback);\n\t});\n\n\treturn require.sandbox(sandboxIdentifier, sandboxOptions, loadedCallback, errorCallback);\n}\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {
                "sjcl": {
                  "where": "inline"
                },
                "./ecc": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/sjcl.js": {
            "requireId": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/sjcl.js",
            "memoizeId": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/sjcl.js",
            "descriptor": {
              "filename": "sjcl.js",
              "filepath": "../node_modules/sjcl/sjcl.js",
              "mtime": 1407996438,
              "code": "/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */\nvar sjcl = {\n  /** @namespace Symmetric ciphers. */\n  cipher: {},\n\n  /** @namespace Hash functions.  Right now only SHA256 is implemented. */\n  hash: {},\n\n  /** @namespace Key exchange functions.  Right now only SRP is implemented. */\n  keyexchange: {},\n  \n  /** @namespace Block cipher modes of operation. */\n  mode: {},\n\n  /** @namespace Miscellaneous.  HMAC and PBKDF2. */\n  misc: {},\n  \n  /**\n   * @namespace Bit array encoders and decoders.\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /** @namespace Exceptions. */\n  exception: {\n    /** @constructor Ciphertext is corrupt. */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @constructor Invalid parameter. */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @constructor Bug or missing feature in SJCL. @constructor */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @constructor Something isn't ready. */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\nif(typeof module !== 'undefined' && module.exports){\n  module.exports = sjcl;\n}\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n *\n * @class Advanced Encryption Standard (low-level interface)\n */\nsjcl.cipher.aes = function (key) {\n  if (!this._tables[0][0][0]) {\n    this._precompute();\n  }\n  \n  var i, j, tmp,\n    encKey, decKey,\n    sbox = this._tables[0][4], decTable = this._tables[1],\n    keyLen = key.length, rcon = 1;\n  \n  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n    throw new sjcl.exception.invalid(\"invalid aes key size\");\n  }\n  \n  this._key = [encKey = key.slice(0), decKey = []];\n  \n  // schedule encryption keys\n  for (i = keyLen; i < 4 * keyLen + 28; i++) {\n    tmp = encKey[i-1];\n    \n    // apply sbox\n    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {\n      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];\n      \n      // shift rows and add rcon\n      if (i%keyLen === 0) {\n        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;\n        rcon = rcon<<1 ^ (rcon>>7)*283;\n      }\n    }\n    \n    encKey[i] = encKey[i-keyLen] ^ tmp;\n  }\n  \n  // schedule decryption keys\n  for (j = 0; i; j++, i--) {\n    tmp = encKey[j&3 ? i : i - 4];\n    if (i<=4 || j<4) {\n      decKey[j] = tmp;\n    } else {\n      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^\n                  decTable[1][sbox[tmp>>16  & 255]] ^\n                  decTable[2][sbox[tmp>>8   & 255]] ^\n                  decTable[3][sbox[tmp      & 255]];\n    }\n  }\n};\n\nsjcl.cipher.aes.prototype = {\n  // public\n  /* Something like this might appear here eventually\n  name: \"AES\",\n  blockSize: 4,\n  keySizes: [4,6,8],\n  */\n  \n  /**\n   * Encrypt an array of 4 big-endian words.\n   * @param {Array} data The plaintext.\n   * @return {Array} The ciphertext.\n   */\n  encrypt:function (data) { return this._crypt(data,0); },\n  \n  /**\n   * Decrypt an array of 4 big-endian words.\n   * @param {Array} data The ciphertext.\n   * @return {Array} The plaintext.\n   */\n  decrypt:function (data) { return this._crypt(data,1); },\n  \n  /**\n   * The expanded S-box and inverse S-box tables.  These will be computed\n   * on the client so that we don't have to send them down the wire.\n   *\n   * There are two tables, _tables[0] is for encryption and\n   * _tables[1] is for decryption.\n   *\n   * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n   * last (_tables[01][4]) is the S-box itself.\n   *\n   * @private\n   */\n  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],\n\n  /**\n   * Expand the S-box tables.\n   *\n   * @private\n   */\n  _precompute: function () {\n   var encTable = this._tables[0], decTable = this._tables[1],\n       sbox = encTable[4], sboxInv = decTable[4],\n       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;\n\n    // Compute double and third tables\n   for (i = 0; i < 256; i++) {\n     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;\n   }\n   \n   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n     // Compute sbox\n     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;\n     s = s>>8 ^ s&255 ^ 99;\n     sbox[x] = s;\n     sboxInv[s] = x;\n     \n     // Compute MixColumns\n     x8 = d[x4 = d[x2 = d[x]]];\n     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;\n     tEnc = d[s]*0x101 ^ s*0x1010100;\n     \n     for (i = 0; i < 4; i++) {\n       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;\n       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;\n     }\n   }\n   \n   // Compactify.  Considerable speedup on Firefox.\n   for (i = 0; i < 5; i++) {\n     encTable[i] = encTable[i].slice(0);\n     decTable[i] = decTable[i].slice(0);\n   }\n  },\n  \n  /**\n   * Encryption and decryption core.\n   * @param {Array} input Four words to be encrypted or decrypted.\n   * @param dir The direction, 0 for encrypt and 1 for decrypt.\n   * @return {Array} The four encrypted or decrypted words.\n   * @private\n   */\n  _crypt:function (input, dir) {\n    if (input.length !== 4) {\n      throw new sjcl.exception.invalid(\"invalid aes block size\");\n    }\n    \n    var key = this._key[dir],\n        // state variables a,b,c,d are loaded with pre-whitened data\n        a = input[0]           ^ key[0],\n        b = input[dir ? 3 : 1] ^ key[1],\n        c = input[2]           ^ key[2],\n        d = input[dir ? 1 : 3] ^ key[3],\n        a2, b2, c2,\n        \n        nInnerRounds = key.length/4 - 2,\n        i,\n        kIndex = 4,\n        out = [0,0,0,0],\n        table = this._tables[dir],\n        \n        // load up the tables\n        t0    = table[0],\n        t1    = table[1],\n        t2    = table[2],\n        t3    = table[3],\n        sbox  = table[4];\n \n    // Inner rounds.  Cribbed from OpenSSL.\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a=a2; b=b2; c=c2;\n    }\n        \n    // Last round.\n    for (i = 0; i < 4; i++) {\n      out[dir ? 3&-i : i] =\n        sbox[a>>>24      ]<<24 ^ \n        sbox[b>>16  & 255]<<16 ^\n        sbox[c>>8   & 255]<<8  ^\n        sbox[d      & 255]     ^\n        key[kIndex++];\n      a2=a; a=b; b=c; c=d; d=a2;\n    }\n    \n    return out;\n  }\n};\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Arrays of bits, encoded as arrays of Numbers.\n *\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} length The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n/** @namespace UTF-8 strings */\nsjcl.codec.utf8String = {\n  /** Convert from a bitArray to a UTF-8 string. */\n  fromBits: function (arr) {\n    var out = \"\", bl = sjcl.bitArray.bitLength(arr), i, tmp;\n    for (i=0; i<bl/8; i++) {\n      if ((i&3) === 0) {\n        tmp = arr[i/4];\n      }\n      out += String.fromCharCode(tmp >>> 24);\n      tmp <<= 8;\n    }\n    return decodeURIComponent(escape(out));\n  },\n  \n  /** Convert from a UTF-8 string to a bitArray. */\n  toBits: function (str) {\n    str = unescape(encodeURIComponent(str));\n    var out = [], i, tmp=0;\n    for (i=0; i<str.length; i++) {\n      tmp = tmp << 8 | str.charCodeAt(i);\n      if ((i&3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n    if (i&3) {\n      out.push(sjcl.bitArray.partial(8*(i&3), tmp));\n    }\n    return out;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Hexadecimal */\nsjcl.codec.hex = {\n  /** Convert from a bitArray to a hex string. */\n  fromBits: function (arr) {\n    var out = \"\", i;\n    for (i=0; i<arr.length; i++) {\n      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);\n    }\n    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, \"$1 \");\n  },\n  /** Convert from a hex string to a bitArray. */\n  toBits: function (str) {\n    var i, out=[], len;\n    str = str.replace(/\\s|0x/g, \"\");\n    len = str.length;\n    str = str + \"00000000\";\n    for (i=0; i<str.length; i+=8) {\n      out.push(parseInt(str.substr(i,8),16)^0);\n    }\n    return sjcl.bitArray.clamp(out, len*4);\n  }\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Base64 encoding/decoding */\nsjcl.codec.base64 = {\n  /** The base64 alphabet.\n   * @private\n   */\n  _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  \n  /** Convert from a bitArray to a base64 string. */\n  fromBits: function (arr, _noEquals, _url) {\n    var out = \"\", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; out.length * 6 <= bl; ) {\n      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);\n      if (bits < 6) {\n        ta = arr[i] << (6-bits);\n        bits += 26;\n        i++;\n      } else {\n        ta <<= 6;\n        bits -= 6;\n      }\n    }\n    while ((out.length & 3) && !_noEquals) { out += \"=\"; }\n    return out;\n  },\n  \n  /** Convert from a base64 string to a bitArray */\n  toBits: function(str, _url) {\n    str = str.replace(/\\s|=/g,'');\n    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; i<str.length; i++) {\n      x = c.indexOf(str.charAt(i));\n      if (x < 0) {\n        throw new sjcl.exception.invalid(\"this isn't base64!\");\n      }\n      if (bits > 26) {\n        bits -= 26;\n        out.push(ta ^ x>>>bits);\n        ta  = x << (32-bits);\n      } else {\n        bits += 6;\n        ta ^= x << (32-bits);\n      }\n    }\n    if (bits&56) {\n      out.push(sjcl.bitArray.partial(bits&56, ta, 1));\n    }\n    return out;\n  }\n};\n\nsjcl.codec.base64url = {\n  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },\n  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n * @class Secure Hash Algorithm, 256 bits.\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    for (i = 512+ol & -512; i <= nl; i+= 512) {\n      this._block(b.splice(0,16));\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    outer: for (; i<64; prime++) {\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          // not a prime\n          continue outer;\n        }\n      }\n      \n      if (i<8) {\n        this._init[i] = frac(Math.pow(prime, 1/2));\n      }\n      this._key[i] = frac(Math.pow(prime, 1/3));\n      i++;\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {  \n    var i, tmp, a, b,\n      w = words.slice(0),\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview CCM mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace CTR mode with CBC MAC. */\nsjcl.mode.ccm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ccm\",\n  \n  /** Encrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function(prf, plaintext, iv, adata, tlen) {\n    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;\n    tlen = tlen || 64;\n    adata = adata || [];\n    \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // compute the tag\n    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n    \n    // encrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    return w.concat(out.data, out.tag);\n  },\n  \n  /** Decrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [[]] adata The authenticated data.\n   * @param {Number} [64] tlen the desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function(prf, ciphertext, iv, adata, tlen) {\n    tlen = tlen || 64;\n    adata = adata || [];\n    var L,\n        w=sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(ciphertext), \n        out = w.clamp(ciphertext, ol - tlen),\n        tag = w.bitSlice(ciphertext, ol - tlen), tag2;\n    \n\n    ol = (ol - tlen) / 8;\n        \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // decrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    // check the tag\n    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n    if (!w.equal(out.tag, tag2)) {\n      throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    }\n    \n    return out.data;\n  },\n\n  /* Compute the (unencrypted) authentication tag, according to the CCM specification\n   * @param {Object} prf The pseudorandom function.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} adata The authenticated data.\n   * @param {Number} tlen the desired tag length, in bits.\n   * @return {bitArray} The tag, but not yet encrypted.\n   * @private\n   */\n  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {\n    // compute B[0]\n    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;\n\n    tlen /= 8;\n  \n    // check tag length and message length\n    if (tlen % 2 || tlen < 4 || tlen > 16) {\n      throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    }\n  \n    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {\n      // I don't want to deal with extracting high words from doubles.\n      throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    }\n\n    // mac the flags\n    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];\n\n    // mac the iv and length\n    mac = w.concat(mac, iv);\n    mac[3] |= w.bitLength(plaintext)/8;\n    mac = prf.encrypt(mac);\n    \n  \n    if (adata.length) {\n      // mac the associated data.  start with its length...\n      tmp = w.bitLength(adata)/8;\n      if (tmp <= 0xFEFF) {\n        macData = [w.partial(16, tmp)];\n      } else if (tmp <= 0xFFFFFFFF) {\n        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);\n      } // else ...\n    \n      // mac the data itself\n      macData = w.concat(macData, adata);\n      for (i=0; i<macData.length; i += 4) {\n        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));\n      }\n    }\n  \n    // mac the plaintext\n    for (i=0; i<plaintext.length; i+=4) {\n      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));\n    }\n\n    return w.clamp(mac, tlen * 8);\n  },\n\n  /** CCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.\n   * May mutate its arguments.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} tag The authentication tag.\n   * @param {Number} tlen The length of th etag, in bits.\n   * @param {Number} L The CCM L value.\n   * @return {Object} An object with data and tag, the en/decryption of data and tag values.\n   * @private\n   */\n  _ctrMode: function(prf, data, iv, tag, tlen, L) {\n    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data);\n\n    // start the ctr\n    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);\n    \n    // en/decrypt the tag\n    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);\n  \n    // en/decrypt the data\n    if (!l) { return {tag:tag, data:[]}; }\n    \n    for (i=0; i<l; i+=4) {\n      ctr[3]++;\n      enc = prf.encrypt(ctr);\n      data[i]   ^= enc[0];\n      data[i+1] ^= enc[1];\n      data[i+2] ^= enc[2];\n      data[i+3] ^= enc[3];\n    }\n    return { tag:tag, data:w.clamp(data,bl) };\n  }\n};\n/** @fileOverview OCB 2.0 implementation\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace\n * Phil Rogaway's Offset CodeBook mode, version 2.0.\n * May be covered by US and international patents.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\nsjcl.mode.ocb2 = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ocb2\",\n  \n  /** Encrypt in OCB mode, version 2.0.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param [false] premac 1 if the authentication data is pre-macced with PMAC.\n   * @return The encrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   */\n  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n    tlen  = tlen || 64;\n  \n    for (i=0; i+4 < plaintext.length; i+=4) {\n      /* Encrypt a non-final block */\n      bi = plaintext.slice(i,i+4);\n      checksum = xor(checksum, bi);\n      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));\n      delta = times2(delta);\n    }\n    \n    /* Chop out the final block */\n    bi = plaintext.slice(i);\n    bl = w.bitLength(bi);\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));\n    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));\n  },\n  \n  /** Decrypt in OCB mode.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.\n   * @return The decrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   * @throws {sjcl.exception.corrupt} if if the message is corrupt.\n   */\n  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    tlen  = tlen || 64;\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        len = sjcl.bitArray.bitLength(ciphertext) - tlen,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n  \n    for (i=0; i+4 < len/32; i+=4) {\n      /* Decrypt a non-final block */\n      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));\n      checksum = xor(checksum, bi);\n      output = output.concat(bi);\n      delta = times2(delta);\n    }\n    \n    /* Chop out and decrypt the final block */\n    bl = len-i*32;\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum, bi);\n    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {\n      throw new sjcl.exception.corrupt(\"ocb: tag doesn't match\");\n    }\n    \n    return output.concat(w.clamp(bi,bl));\n  },\n  \n  /** PMAC authentication for OCB associated data.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} adata The authenticated data.\n   */\n  pmac: function(prp, adata) {\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = prp.encrypt([0,0,0,0]),\n        bi;\n        \n    delta = xor(delta,times2(times2(delta)));\n \n    for (i=0; i+4<adata.length; i+=4) {\n      delta = times2(delta);\n      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));\n    }\n    \n    bi = adata.slice(i);\n    if (w.bitLength(bi) < 128) {\n      delta = xor(delta,times2(delta));\n      bi = w.concat(bi,[0x80000000|0,0,0,0]);\n    }\n    checksum = xor(checksum, bi);\n    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));\n  },\n  \n  /** Double a block of words, OCB style.\n   * @private\n   */\n  _times2: function(x) {\n    return [x[0]<<1 ^ x[1]>>>31,\n            x[1]<<1 ^ x[2]>>>31,\n            x[2]<<1 ^ x[3]>>>31,\n            x[3]<<1 ^ (x[0]>>>31)*0x87];\n  }\n};\n/** @fileOverview GCM mode implementation.\n *\n * @author Juho Vähä-Herttua\n */\n\n/** @namespace Galois/Counter mode. */\nsjcl.mode.gcm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"gcm\",\n  \n  /** Encrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function (prf, plaintext, iv, adata, tlen) {\n    var out, data = plaintext.slice(0), w=sjcl.bitArray;\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // encrypt and tag\n    out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);\n\n    return w.concat(out.data, out.tag);\n  },\n  \n  /** Decrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function (prf, ciphertext, iv, adata, tlen) {\n    var out, data = ciphertext.slice(0), tag, w=sjcl.bitArray, l=w.bitLength(data);\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // Slice tag out of data\n    if (tlen <= l) {\n      tag = w.bitSlice(data, l-tlen);\n      data = w.bitSlice(data, 0, l-tlen);\n    } else {\n      tag = data;\n      data = [];\n    }\n\n    // decrypt and tag\n    out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);\n\n    if (!w.equal(out.tag, tag)) {\n      throw new sjcl.exception.corrupt(\"gcm: tag doesn't match\");\n    }\n    return out.data;\n  },\n\n  /* Compute the galois multiplication of X and Y\n   * @private\n   */\n  _galoisMultiply: function (x, y) {\n    var i, j, xi, Zi, Vi, lsb_Vi, w=sjcl.bitArray, xor=w._xor4;\n\n    Zi = [0,0,0,0];\n    Vi = y.slice(0);\n\n    // Block size is 128 bits, run 128 times to get Z_128\n    for (i=0; i<128; i++) {\n      xi = (x[Math.floor(i/32)] & (1 << (31-i%32))) !== 0;\n      if (xi) {\n        // Z_i+1 = Z_i ^ V_i\n        Zi = xor(Zi, Vi);\n      }\n\n      // Store the value of LSB(V_i)\n      lsb_Vi = (Vi[3] & 1) !== 0;\n\n      // V_i+1 = V_i >> 1\n      for (j=3; j>0; j--) {\n        Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);\n      }\n      Vi[0] = Vi[0] >>> 1;\n\n      // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n      if (lsb_Vi) {\n        Vi[0] = Vi[0] ^ (0xe1 << 24);\n      }\n    }\n    return Zi;\n  },\n\n  _ghash: function(H, Y0, data) {\n    var Yi, i, l = data.length;\n\n    Yi = Y0.slice(0);\n    for (i=0; i<l; i+=4) {\n      Yi[0] ^= 0xffffffff&data[i];\n      Yi[1] ^= 0xffffffff&data[i+1];\n      Yi[2] ^= 0xffffffff&data[i+2];\n      Yi[3] ^= 0xffffffff&data[i+3];\n      Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);\n    }\n    return Yi;\n  },\n\n  /** GCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in GCM-style CTR mode.\n   * @param {Boolean} encrypt True if encrypt, false if decrypt.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} adata The associated data to be tagged.\n   * @param {Number} tlen The length of the tag, in bits.\n   */\n  _ctrMode: function(encrypt, prf, data, adata, iv, tlen) {\n    var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w=sjcl.bitArray;\n\n    // Calculate data lengths\n    l = data.length;\n    bl = w.bitLength(data);\n    abl = w.bitLength(adata);\n    ivbl = w.bitLength(iv);\n\n    // Calculate the parameters\n    H = prf.encrypt([0,0,0,0]);\n    if (ivbl === 96) {\n      J0 = iv.slice(0);\n      J0 = w.concat(J0, [1]);\n    } else {\n      J0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], iv);\n      J0 = sjcl.mode.gcm._ghash(H, J0, [0,0,Math.floor(ivbl/0x100000000),ivbl&0xffffffff]);\n    }\n    S0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], adata);\n\n    // Initialize ctr and tag\n    ctr = J0.slice(0);\n    tag = S0.slice(0);\n\n    // If decrypting, calculate hash\n    if (!encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Encrypt all the data\n    for (i=0; i<l; i+=4) {\n       ctr[3]++;\n       enc = prf.encrypt(ctr);\n       data[i]   ^= enc[0];\n       data[i+1] ^= enc[1];\n       data[i+2] ^= enc[2];\n       data[i+3] ^= enc[3];\n    }\n    data = w.clamp(data, bl);\n\n    // If encrypting, calculate hash\n    if (encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Calculate last block from bit lengths, ugly because bitwise operations are 32-bit\n    last = [\n      Math.floor(abl/0x100000000), abl&0xffffffff,\n      Math.floor(bl/0x100000000), bl&0xffffffff\n    ];\n\n    // Calculate the final tag block\n    tag = sjcl.mode.gcm._ghash(H, tag, last);\n    enc = prf.encrypt(J0);\n    tag[0] ^= enc[0];\n    tag[1] ^= enc[1];\n    tag[2] ^= enc[2];\n    tag[3] ^= enc[3];\n\n    return { tag:w.bitSlice(tag, 0, tlen), data:data };\n  }\n};\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};/** @fileOverview Password-based key-derivation function, version 2.0.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Password-Based Key-Derivation Function, version 2.0.\n *\n * Generate keys from passwords using PBKDF2-HMAC-SHA256.\n *\n * This is the method specified by RSA's PKCS #5 standard.\n *\n * @param {bitArray|String} password  The password.\n * @param {bitArray|String} salt The salt.  Should have lots of entropy.\n * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.\n * @param {Number} [length] The length of the derived key.  Defaults to the\n                            output size of the hash function.\n * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.\n * @return {bitArray} the derived key.\n */\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n  count = count || 1000;\n  \n  if (length < 0 || count < 0) {\n    throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  }\n  \n  if (typeof password === \"string\") {\n    password = sjcl.codec.utf8String.toBits(password);\n  }\n  \n  if (typeof salt === \"string\") {\n    salt = sjcl.codec.utf8String.toBits(salt);\n  }\n  \n  Prff = Prff || sjcl.misc.hmac;\n  \n  var prf = new Prff(password),\n      u, ui, i, j, k, out = [], b = sjcl.bitArray;\n\n  for (k = 1; 32 * out.length < (length || 1); k++) {\n    u = ui = prf.encrypt(b.concat(salt,[k]));\n    \n    for (i=1; i<count; i++) {\n      ui = prf.encrypt(ui);\n      for (j=0; j<ui.length; j++) {\n        u[j] ^= ui[j];\n      }\n    }\n    \n    out = out.concat(u);\n  }\n\n  if (length) { out = b.clamp(out, length); }\n\n  return out;\n};\n/** @fileOverview Random number generator.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Michael Brooks\n */\n\n/** @constructor\n * @class Random number generator\n * @description\n * <b>Use sjcl.random as a singleton for this class!</b>\n * <p>\n * This random number generator is a derivative of Ferguson and Schneier's\n * generator Fortuna.  It collects entropy from various events into several\n * pools, implemented by streaming SHA-256 instances.  It differs from\n * ordinary Fortuna in a few ways, though.\n * </p>\n *\n * <p>\n * Most importantly, it has an entropy estimator.  This is present because\n * there is a strong conflict here between making the generator available\n * as soon as possible, and making sure that it doesn't \"run on empty\".\n * In Fortuna, there is a saved state file, and the system is likely to have\n * time to warm up.\n * </p>\n *\n * <p>\n * Second, because users are unlikely to stay on the page for very long,\n * and to speed startup time, the number of pools increases logarithmically:\n * a new pool is created when the previous one is actually used for a reseed.\n * This gives the same asymptotic guarantees as Fortuna, but gives more\n * entropy to early reseeds.\n * </p>\n *\n * <p>\n * The entire mechanism here feels pretty klunky.  Furthermore, there are\n * several improvements that should be made, including support for\n * dedicated cryptographic functions that may be present in some browsers;\n * state files in local storage; cookies containing randomness; etc.  So\n * look for improvements in future versions.\n * </p>\n */\nsjcl.prng = function(defaultParanoia) {\n  \n  /* private */\n  this._pools                   = [new sjcl.hash.sha256()];\n  this._poolEntropy             = [0];\n  this._reseedCount             = 0;\n  this._robins                  = {};\n  this._eventId                 = 0;\n  \n  this._collectorIds            = {};\n  this._collectorIdNext         = 0;\n  \n  this._strength                = 0;\n  this._poolStrength            = 0;\n  this._nextReseed              = 0;\n  this._key                     = [0,0,0,0,0,0,0,0];\n  this._counter                 = [0,0,0,0];\n  this._cipher                  = undefined;\n  this._defaultParanoia         = defaultParanoia;\n  \n  /* event listener stuff */\n  this._collectorsStarted       = false;\n  this._callbacks               = {progress: {}, seeded: {}};\n  this._callbackI               = 0;\n  \n  /* constants */\n  this._NOT_READY               = 0;\n  this._READY                   = 1;\n  this._REQUIRES_RESEED         = 2;\n\n  this._MAX_WORDS_PER_BURST     = 65536;\n  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];\n  this._MILLISECONDS_PER_RESEED = 30000;\n  this._BITS_PER_RESEED         = 80;\n};\n \nsjcl.prng.prototype = {\n  /** Generate several random words, and return them in an array.\n   * A word consists of 32 bits (4 bytes)\n   * @param {Number} nwords The number of words to generate.\n   */\n  randomWords: function (nwords, paranoia) {\n    var out = [], i, readiness = this.isReady(paranoia), g;\n  \n    if (readiness === this._NOT_READY) {\n      throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    } else if (readiness & this._REQUIRES_RESEED) {\n      this._reseedFromPools(!(readiness & this._READY));\n    }\n  \n    for (i=0; i<nwords; i+= 4) {\n      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {\n        this._gate();\n      }\n   \n      g = this._gen4words();\n      out.push(g[0],g[1],g[2],g[3]);\n    }\n    this._gate();\n  \n    return out.slice(0,nwords);\n  },\n  \n  setDefaultParanoia: function (paranoia, allowZeroParanoia) {\n    if (paranoia === 0 && allowZeroParanoia !== \"Setting paranoia=0 will ruin your security; use it only for testing\") {\n      throw \"Setting paranoia=0 will ruin your security; use it only for testing\";\n    }\n\n    this._defaultParanoia = paranoia;\n  },\n  \n  /**\n   * Add entropy to the pools.\n   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string\n   * @param {Number} estimatedEntropy The estimated entropy of data, in bits\n   * @param {String} source The source of the entropy, eg \"mouse\"\n   */\n  addEntropy: function (data, estimatedEntropy, source) {\n    source = source || \"user\";\n  \n    var id,\n      i, tmp,\n      t = (new Date()).valueOf(),\n      robin = this._robins[source],\n      oldReady = this.isReady(), err = 0, objName;\n      \n    id = this._collectorIds[source];\n    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }\n      \n    if (robin === undefined) { robin = this._robins[source] = 0; }\n    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;\n  \n    switch(typeof(data)) {\n      \n    case \"number\":\n      if (estimatedEntropy === undefined) {\n        estimatedEntropy = 1;\n      }\n      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);\n      break;\n      \n    case \"object\":\n      objName = Object.prototype.toString.call(data);\n      if (objName === \"[object Uint32Array]\") {\n        tmp = [];\n        for (i = 0; i < data.length; i++) {\n          tmp.push(data[i]);\n        }\n        data = tmp;\n      } else {\n        if (objName !== \"[object Array]\") {\n          err = 1;\n        }\n        for (i=0; i<data.length && !err; i++) {\n          if (typeof(data[i]) !== \"number\") {\n            err = 1;\n          }\n        }\n      }\n      if (!err) {\n        if (estimatedEntropy === undefined) {\n          /* horrible entropy estimator */\n          estimatedEntropy = 0;\n          for (i=0; i<data.length; i++) {\n            tmp= data[i];\n            while (tmp>0) {\n              estimatedEntropy++;\n              tmp = tmp >>> 1;\n            }\n          }\n        }\n        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));\n      }\n      break;\n      \n    case \"string\":\n      if (estimatedEntropy === undefined) {\n       /* English text has just over 1 bit per character of entropy.\n        * But this might be HTML or something, and have far less\n        * entropy than English...  Oh well, let's just say one bit.\n        */\n       estimatedEntropy = data.length;\n      }\n      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);\n      this._pools[robin].update(data);\n      break;\n      \n    default:\n      err=1;\n    }\n    if (err) {\n      throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    }\n  \n    /* record the new strength */\n    this._poolEntropy[robin] += estimatedEntropy;\n    this._poolStrength += estimatedEntropy;\n  \n    /* fire off events */\n    if (oldReady === this._NOT_READY) {\n      if (this.isReady() !== this._NOT_READY) {\n        this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n      }\n      this._fireEvent(\"progress\", this.getProgress());\n    }\n  },\n  \n  /** Is the generator ready? */\n  isReady: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength && this._strength >= entropyRequired) {\n      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?\n        this._REQUIRES_RESEED | this._READY :\n        this._READY;\n    } else {\n      return (this._poolStrength >= entropyRequired) ?\n        this._REQUIRES_RESEED | this._NOT_READY :\n        this._NOT_READY;\n    }\n  },\n  \n  /** Get the generator's progress toward readiness, as a fraction */\n  getProgress: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength >= entropyRequired) {\n      return 1.0;\n    } else {\n      return (this._poolStrength > entropyRequired) ?\n        1.0 :\n        this._poolStrength / entropyRequired;\n    }\n  },\n  \n  /** start the built-in entropy collectors */\n  startCollectors: function () {\n    if (this._collectorsStarted) { return; }\n  \n    this._eventListener = {\n      loadTimeCollector: this._bind(this._loadTimeCollector),\n      mouseCollector: this._bind(this._mouseCollector),\n      keyboardCollector: this._bind(this._keyboardCollector),\n      accelerometerCollector: this._bind(this._accelerometerCollector)\n    }\n\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.addEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.addEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.addEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n    } else if (document.attachEvent) {\n      document.attachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.attachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.attachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    } else {\n      throw new sjcl.exception.bug(\"can't attach event\");\n    }\n  \n    this._collectorsStarted = true;\n  },\n  \n  /** stop the built-in entropy collectors */\n  stopCollectors: function () {\n    if (!this._collectorsStarted) { return; }\n  \n    if (window.removeEventListener) {\n      window.removeEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.removeEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.removeEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.removeEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n    } else if (document.detachEvent) {\n      document.detachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.detachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.detachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    }\n\n    this._collectorsStarted = false;\n  },\n  \n  /* use a cookie to store entropy.\n  useCookie: function (all_cookies) {\n      throw new sjcl.exception.bug(\"random: useCookie is unimplemented\");\n  },*/\n  \n  /** add an event listener for progress or seeded-ness. */\n  addEventListener: function (name, callback) {\n    this._callbacks[name][this._callbackI++] = callback;\n  },\n  \n  /** remove an event listener for progress or seeded-ness */\n  removeEventListener: function (name, cb) {\n    var i, j, cbs=this._callbacks[name], jsTemp=[];\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n        jsTemp.push(j);\n      }\n    }\n\n    for (i=0; i<jsTemp.length; i++) {\n      j = jsTemp[i];\n      delete cbs[j];\n    }\n  },\n  \n  _bind: function (func) {\n    var that = this;\n    return function () {\n      func.apply(that, arguments);\n    };\n  },\n\n  /** Generate 4 random words, no reseed, no gate.\n   * @private\n   */\n  _gen4words: function () {\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n    return this._cipher.encrypt(this._counter);\n  },\n  \n  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.\n   * @private\n   */\n  _gate: function () {\n    this._key = this._gen4words().concat(this._gen4words());\n    this._cipher = new sjcl.cipher.aes(this._key);\n  },\n  \n  /** Reseed the generator with the given words\n   * @private\n   */\n  _reseed: function (seedWords) {\n    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n    this._cipher = new sjcl.cipher.aes(this._key);\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n  },\n  \n  /** reseed the data from the entropy pools\n   * @param full If set, use all the entropy pools in the reseed.\n   */\n  _reseedFromPools: function (full) {\n    var reseedData = [], strength = 0, i;\n  \n    this._nextReseed = reseedData[0] =\n      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;\n    \n    for (i=0; i<16; i++) {\n      /* On some browsers, this is cryptographically random.  So we might\n       * as well toss it in the pot and stir...\n       */\n      reseedData.push(Math.random()*0x100000000|0);\n    }\n    \n    for (i=0; i<this._pools.length; i++) {\n     reseedData = reseedData.concat(this._pools[i].finalize());\n     strength += this._poolEntropy[i];\n     this._poolEntropy[i] = 0;\n   \n     if (!full && (this._reseedCount & (1<<i))) { break; }\n    }\n  \n    /* if we used the last pool, push a new one onto the stack */\n    if (this._reseedCount >= 1 << this._pools.length) {\n     this._pools.push(new sjcl.hash.sha256());\n     this._poolEntropy.push(0);\n    }\n  \n    /* how strong was this reseed? */\n    this._poolStrength -= strength;\n    if (strength > this._strength) {\n      this._strength = strength;\n    }\n  \n    this._reseedCount ++;\n    this._reseed(reseedData);\n  },\n  \n  _keyboardCollector: function () {\n    this._addCurrentTimeToEntropy(1);\n  },\n  \n  _mouseCollector: function (ev) {\n    var x = ev.x || ev.clientX || ev.offsetX || 0, y = ev.y || ev.clientY || ev.offsetY || 0;\n    sjcl.random.addEntropy([x,y], 2, \"mouse\");\n    this._addCurrentTimeToEntropy(0);\n  },\n  \n  _loadTimeCollector: function () {\n    this._addCurrentTimeToEntropy(2);\n  },\n\n  _addCurrentTimeToEntropy: function (estimatedEntropy) {\n    if (window && window.performance && typeof window.performance.now === \"function\") {\n      //how much entropy do we want to add here?\n      sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, \"loadtime\");\n    } else {\n      sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, \"loadtime\");\n    }\n  },\n  _accelerometerCollector: function (ev) {\n    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;\n    if(window.orientation){\n      var or = window.orientation;\n      if (typeof or === \"number\") {\n        sjcl.random.addEntropy(or, 1, \"accelerometer\");\n      }\n    }\n    if (ac) {\n      sjcl.random.addEntropy(ac, 2, \"accelerometer\");\n    }\n    this._addCurrentTimeToEntropy(0);\n  },\n\n  _fireEvent: function (name, arg) {\n    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];\n    /* TODO: there is a race condition between removing collectors and firing them */\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j)) {\n        cbsTemp.push(cbs[j]);\n      }\n    }\n\n    for (j=0; j<cbsTemp.length; j++) {\n      cbsTemp[j](arg);\n    }\n  }\n};\n\n/** an instance for the prng.\n* @see sjcl.prng\n*/\nsjcl.random = new sjcl.prng(6);\n\n(function(){\n  // function for getting nodejs crypto module. catches and ignores errors.\n  function getCryptoModule() {\n    try {\n      return require('crypto');\n    }\n    catch (e) {\n      return null;\n    }\n  }\n\n  try {\n    var buf, crypt, ab;\n\n    // get cryptographically strong entropy depending on runtime environment\n    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {\n      buf = crypt.randomBytes(1024/8);\n      buf = new Uint32Array(new Uint8Array(buf).buffer);\n      sjcl.random.addEntropy(buf, 1024, \"crypto.randomBytes\");\n\n    } else if (window && Uint32Array) {\n      ab = new Uint32Array(32);\n      if (window.crypto && window.crypto.getRandomValues) {\n        window.crypto.getRandomValues(ab);\n      } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n        window.msCrypto.getRandomValues(ab);\n      } else {\n        return;\n      }\n\n      // get cryptographically strong entropy in Webkit\n      sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n\n    } else {\n      // no getRandomValues :-(\n    }\n  } catch (e) {\n    if (typeof window !== 'undefined' && window.console) {\n      console.log(\"There was an error collecting entropy from the browser:\");\n      console.log(e);\n      //we do not want the library to fail due to randomness not being maintained.\n    }\n  }\n}());\n/** @fileOverview Convenince functions centered around JSON encapsulation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n /** @namespace JSON encapsulation */\n sjcl.json = {\n  /** Default values for encryption */\n  defaults: { v:1, iter:1000, ks:128, ts:64, mode:\"ccm\", adata:\"\", cipher:\"aes\" },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {Object} The cipher raw data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  _encrypt: function (password, plaintext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },\n                                  j.defaults), tmp, prp, adata;\n    j._add(p, params);\n    adata = p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {\n      tmp = password.kem();\n      p.kemtag = tmp.tag;\n      password = tmp.key.slice(0,p.ks/32);\n    }\n    if (typeof plaintext === \"string\") {\n      plaintext = sjcl.codec.utf8String.toBits(plaintext);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    /* do the encryption */\n    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n\n    //return j.encode(j._subtract(p, j.defaults));\n    return p;\n  },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {String} The ciphertext serialized data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  encrypt: function (password, plaintext, params, rp) {\n    var j = sjcl.json, p = j._encrypt.apply(j, arguments);\n    return j.encode(p);\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {Object} ciphertext The cipher raw data to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  _decrypt: function (password, ciphertext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (!p.iv) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt  = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {\n      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* do the decryption */\n    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    return sjcl.codec.utf8String.fromBits(ct);\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} ciphertext The ciphertext to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  decrypt: function (password, ciphertext, params, rp) {\n    var j = sjcl.json;\n    return j._decrypt(password, j.decode(ciphertext), params, rp);\n  },\n  \n  /** Encode a flat structure into a JSON string.\n   * @param {Object} obj The structure to encode.\n   * @return {String} A JSON string.\n   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.\n   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.\n   */\n  encode: function (obj) {\n    var i, out='{', comma='';\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (!i.match(/^[a-z0-9]+$/i)) {\n          throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        }\n        out += comma + '\"' + i + '\":';\n        comma = ',';\n\n        switch (typeof obj[i]) {\n          case 'number':\n          case 'boolean':\n            out += obj[i];\n            break;\n\n          case 'string':\n            out += '\"' + escape(obj[i]) + '\"';\n            break;\n\n          case 'object':\n            out += '\"' + sjcl.codec.base64.fromBits(obj[i],0) + '\"';\n            break;\n\n          default:\n            throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n    return out+'}';\n  },\n  \n  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,\n   * adata, salt and iv will be base64-decoded.\n   * @param {String} str The string.\n   * @return {Object} The decoded structure.\n   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.\n   */\n  decode: function (str) {\n    str = str.replace(/\\s/g,'');\n    if (!str.match(/^\\{.*\\}$/)) { \n      throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    }\n    var a = str.replace(/^\\{|\\}$/g, '').split(/,/), out={}, i, m;\n    for (i=0; i<a.length; i++) {\n      if (!(m=a[i].match(/^(?:([\"']?)([a-z][a-z0-9]*)\\1):(?:(\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\")$/i))) {\n        throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      }\n      if (m[3]) {\n        out[m[2]] = parseInt(m[3],10);\n      } else {\n        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n      }\n    }\n    return out;\n  },\n  \n  /** Insert all elements of src into target, modifying and returning target.\n   * @param {Object} target The object to be modified.\n   * @param {Object} src The object to pull data from.\n   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.\n   * @return {Object} target.\n   * @private\n   */\n  _add: function (target, src, requireSame) {\n    if (target === undefined) { target = {}; }\n    if (src === undefined) { return target; }\n    var i;\n    for (i in src) {\n      if (src.hasOwnProperty(i)) {\n        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n          throw new sjcl.exception.invalid(\"required parameter overridden\");\n        }\n        target[i] = src[i];\n      }\n    }\n    return target;\n  },\n  \n  /** Remove all elements of minus from plus.  Does not modify plus.\n   * @private\n   */\n  _subtract: function (plus, minus) {\n    var out = {}, i;\n\n    for (i in plus) {\n      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n        out[i] = plus[i];\n      }\n    }\n\n    return out;\n  },\n  \n  /** Return only the specified elements of src.\n   * @private\n   */\n  _filter: function (src, filter) {\n    var out = {}, i;\n    for (i=0; i<filter.length; i++) {\n      if (src[filter[i]] !== undefined) {\n        out[filter[i]] = src[filter[i]];\n      }\n    }\n    return out;\n  }\n};\n\n/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} plaintext The data to encrypt.\n * @param {Object} [params] The parameters including tag, iv and salt.\n * @param {Object} [rp] A returned version with filled-in parameters.\n * @return {String} The ciphertext.\n */\nsjcl.encrypt = sjcl.json.encrypt;\n\n/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} ciphertext The ciphertext to decrypt.\n * @param {Object} [params] Additional non-default parameters.\n * @param {Object} [rp] A returned object with filled parameters.\n * @return {String} The plaintext.\n */\nsjcl.decrypt = sjcl.json.decrypt;\n\n/** The cache for cachedPbkdf2.\n * @private\n */\nsjcl.misc._pbkdf2Cache = {};\n\n/** Cached PBKDF2 key derivation.\n * @param {String} password The password.\n * @param {Object} [obj] The derivation params (iteration count and optional salt).\n * @return {Object} The derived data in key, the salt in salt.\n */\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;\n  \n  obj = obj || {};\n  iter = obj.iter || 1000;\n  \n  /* open the cache for this password and iteration count */\n  cp = cache[password] = cache[password] || {};\n  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?\n                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };\n          \n  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;\n  \n  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n  return { key: c[salt].slice(0), salt:salt.slice(0) };\n};\n\n\n/**\n * @constructor\n * Constructs a new bignum from another bignum, a number or a hex string.\n */\nsjcl.bn = function(it) {\n  this.initWith(it);\n};\n\nsjcl.bn.prototype = {\n  radix: 24,\n  maxMul: 8,\n  _class: sjcl.bn,\n  \n  copy: function() {\n    return new this._class(this);\n  },\n\n  /**\n   * Initializes this with it, either as a bn, a number, or a hex string.\n   */\n  initWith: function(it) {\n    var i=0, k;\n    switch(typeof it) {\n    case \"object\":\n      this.limbs = it.limbs.slice(0);\n      break;\n      \n    case \"number\":\n      this.limbs = [it];\n      this.normalize();\n      break;\n      \n    case \"string\":\n      it = it.replace(/^0x/, '');\n      this.limbs = [];\n      // hack\n      k = this.radix / 4;\n      for (i=0; i < it.length; i+=k) {\n        this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));\n      }\n      break;\n\n    default:\n      this.limbs = [0];\n    }\n    return this;\n  },\n\n  /**\n   * Returns true if \"this\" and \"that\" are equal.  Calls fullReduce().\n   * Equality test is in constant time.\n   */\n  equals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var difference = 0, i;\n    this.fullReduce();\n    that.fullReduce();\n    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {\n      difference |= this.getLimb(i) ^ that.getLimb(i);\n    }\n    return (difference === 0);\n  },\n  \n  /**\n   * Get the i'th limb of this, zero if i is too large.\n   */\n  getLimb: function(i) {\n    return (i >= this.limbs.length) ? 0 : this.limbs[i];\n  },\n  \n  /**\n   * Constant time comparison function.\n   * Returns 1 if this >= that, or zero otherwise.\n   */\n  greaterEquals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var less = 0, greater = 0, i, a, b;\n    i = Math.max(this.limbs.length, that.limbs.length) - 1;\n    for (; i>= 0; i--) {\n      a = this.getLimb(i);\n      b = that.getLimb(i);\n      greater |= (b - a) & ~less;\n      less |= (a - b) & ~greater;\n    }\n    return (greater | ~less) >>> 31;\n  },\n  \n  /**\n   * Convert to a hex string.\n   */\n  toString: function() {\n    this.fullReduce();\n    var out=\"\", i, s, l = this.limbs;\n    for (i=0; i < this.limbs.length; i++) {\n      s = l[i].toString(16);\n      while (i < this.limbs.length - 1 && s.length < 6) {\n        s = \"0\" + s;\n      }\n      out = s + out;\n    }\n    return \"0x\"+out;\n  },\n  \n  /** this += that.  Does not normalize. */\n  addM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] += ll[i];\n    }\n    return this;\n  },\n  \n  /** this *= 2.  Requires normalized; ends up normalized. */\n  doubleM: function() {\n    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;\n    for (i=0; i<l.length; i++) {\n      tmp = l[i];\n      tmp = tmp+tmp+carry;\n      l[i] = tmp & m;\n      carry = tmp >> r;\n    }\n    if (carry) {\n      l.push(carry);\n    }\n    return this;\n  },\n  \n  /** this /= 2, rounded down.  Requires normalized; ends up normalized. */\n  halveM: function() {\n    var i, carry=0, tmp, r=this.radix, l=this.limbs;\n    for (i=l.length-1; i>=0; i--) {\n      tmp = l[i];\n      l[i] = (tmp+carry)>>1;\n      carry = (tmp&1) << r;\n    }\n    if (!l[l.length-1]) {\n      l.pop();\n    }\n    return this;\n  },\n\n  /** this -= that.  Does not normalize. */\n  subM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] -= ll[i];\n    }\n    return this;\n  },\n  \n  mod: function(that) {\n    var neg = !this.greaterEquals(new sjcl.bn(0));\n    \n    that = new sjcl.bn(that).normalize(); // copy before we begin\n    var out = new sjcl.bn(this).normalize(), ci=0;\n    \n    if (neg) out = (new sjcl.bn(0)).subM(out).normalize();\n    \n    for (; out.greaterEquals(that); ci++) {\n      that.doubleM();\n    }\n    \n    if (neg) out = that.sub(out).normalize();\n    \n    for (; ci > 0; ci--) {\n      that.halveM();\n      if (out.greaterEquals(that)) {\n        out.subM(that).normalize();\n      }\n    }\n    return out.trim();\n  },\n  \n  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */\n  inverseMod: function(p) {\n    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;\n    \n    if (!(p.limbs[0] & 1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p must be odd\"));\n    }\n    \n    // invariant: y is odd\n    do {\n      if (x.limbs[0] & 1) {\n        if (!x.greaterEquals(y)) {\n          // x < y; swap everything\n          tmp = x; x = y; y = tmp;\n          tmp = a; a = b; b = tmp;\n        }\n        x.subM(y);\n        x.normalize();\n        \n        if (!a.greaterEquals(b)) {\n          a.addM(p);\n        }\n        a.subM(b);\n      }\n      \n      // cut everything in half\n      x.halveM();\n      if (a.limbs[0] & 1) {\n        a.addM(p);\n      }\n      a.normalize();\n      a.halveM();\n      \n      // check for termination: x ?= 0\n      for (i=nz=0; i<x.limbs.length; i++) {\n        nz |= x.limbs[i];\n      }\n    } while(nz);\n    \n    if (!y.equals(1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p and x must be relatively prime\"));\n    }\n    \n    return b;\n  },\n  \n  /** this + that.  Does not normalize. */\n  add: function(that) {\n    return this.copy().addM(that);\n  },\n\n  /** this - that.  Does not normalize. */\n  sub: function(that) {\n    return this.copy().subM(that);\n  },\n  \n  /** this * that.  Normalizes and reduces. */\n  mul: function(that) {\n    if (typeof(that) === \"number\") { that = new this._class(that); }\n    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;\n\n    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {\n      c[i] = 0;\n    }\n    for (i=0; i<al; i++) {\n      ai = a[i];\n      for (j=0; j<bl; j++) {\n        c[i+j] += ai * b[j];\n      }\n     \n      if (!--ii) {\n        ii = this.maxMul;\n        out.cnormalize();\n      }\n    }\n    return out.cnormalize().reduce();\n  },\n\n  /** this ^ 2.  Normalizes and reduces. */\n  square: function() {\n    return this.mul(this);\n  },\n\n  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */\n  power: function(l) {\n    if (typeof(l) === \"number\") {\n      l = [l];\n    } else if (l.limbs !== undefined) {\n      l = l.normalize().limbs;\n    }\n    var i, j, out = new this._class(1), pow = this;\n\n    for (i=0; i<l.length; i++) {\n      for (j=0; j<this.radix; j++) {\n        if (l[i] & (1<<j)) {\n          out = out.mul(pow);\n        }\n        pow = pow.square();\n      }\n    }\n    \n    return out;\n  },\n\n  /** this * that mod N */\n  mulmod: function(that, N) {\n    return this.mod(N).mul(that.mod(N)).mod(N);\n  },\n\n  /** this ^ x mod N */\n  powermod: function(x, N) {\n    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);\n    while (true) {\n      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }\n      k.halveM();\n      if (k.equals(0)) { break; }\n      a = a.mulmod(a, N);\n    }\n    return result.normalize().reduce();\n  },\n\n  trim: function() {\n    var l = this.limbs, p;\n    do {\n      p = l.pop();\n    } while (l.length && p === 0);\n    l.push(p);\n    return this;\n  },\n  \n  /** Reduce mod a modulus.  Stubbed for subclassing. */\n  reduce: function() {\n    return this;\n  },\n\n  /** Reduce and normalize. */\n  fullReduce: function() {\n    return this.normalize();\n  },\n  \n  /** Propagate carries. */\n  normalize: function() {\n    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {\n      l = (limbs[i]||0) + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    if (carry === -1) {\n      limbs[i-1] -= pv;\n    }\n    return this;\n  },\n\n  /** Constant-time normalize. Does not allocate additional space. */\n  cnormalize: function() {\n    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll-1; i++) {\n      l = limbs[i] + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    limbs[i] += carry;\n    return this;\n  },\n  \n  /** Serialize to a bit array */\n  toBits: function(len) {\n    this.fullReduce();\n    len = len || this.exponent || this.bitLength();\n    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,\n        out = [w.partial(e, this.getLimb(i))];\n    for (i--; i >= 0; i--) {\n      out = w.concat(out, [w.partial(Math.min(this.radix,len), this.getLimb(i))]);\n      len -= this.radix;\n    }\n    return out;\n  },\n  \n  /** Return the length in bits, rounded up to the nearest byte. */\n  bitLength: function() {\n    this.fullReduce();\n    var out = this.radix * (this.limbs.length - 1),\n        b = this.limbs[this.limbs.length - 1];\n    for (; b; b >>>= 1) {\n      out ++;\n    }\n    return out+7 & -8;\n  }\n};\n\n/** @memberOf sjcl.bn\n* @this { sjcl.bn }\n*/\nsjcl.bn.fromBits = function(bits) {\n  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,\n      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;\n  \n  words[0] = w.extract(bits, 0, e);\n  for (; e < l; e += t.radix) {\n    words.unshift(w.extract(bits, e, t.radix));\n  }\n\n  out.limbs = words;\n  return out;\n};\n\n\n\nsjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));\nsjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;\n\n/**\n * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,\n * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.\n */\nsjcl.bn.pseudoMersennePrime = function(exponent, coeff) {\n  /** @constructor \n  * @private\n  */\n  function p(it) {\n    this.initWith(it);\n    /*if (this.limbs[this.modOffset]) {\n      this.reduce();\n    }*/\n  }\n\n  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;\n  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);\n  ppr.exponent = exponent;\n  ppr.offset = [];\n  ppr.factor = [];\n  ppr.minOffset = mo;\n  ppr.fullMask = 0;\n  ppr.fullOffset = [];\n  ppr.fullFactor = [];\n  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));\n  \n  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);\n\n  for (i=0; i<coeff.length; i++) {\n    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);\n    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);\n    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);\n    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);\n    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));\n    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative\n  }\n  ppr._class = p;\n  ppr.modulus.cnormalize();\n\n  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p.\n   * @memberof sjcl.bn\n   * @this { sjcl.bn }\n   */\n  ppr.reduce = function() {\n    var i, k, l, mo = this.modOffset, limbs = this.limbs, off = this.offset, ol = this.offset.length, fac = this.factor, ll;\n\n    i = this.minOffset;\n    while (limbs.length > mo) {\n      l = limbs.pop();\n      ll = limbs.length;\n      for (k=0; k<ol; k++) {\n        limbs[ll+off[k]] -= fac[k] * l;\n      }\n      \n      i--;\n      if (!i) {\n        limbs.push(0);\n        this.cnormalize();\n        i = this.minOffset;\n      }\n    }\n    this.cnormalize();\n\n    return this;\n  };\n  \n  /** @memberof sjcl.bn\n  * @this { sjcl.bn }\n  */\n  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {\n    var limbs = this.limbs, i = limbs.length - 1, k, l;\n    this.reduce();\n    if (i === this.modOffset - 1) {\n      l = limbs[i] & this.fullMask;\n      limbs[i] -= l;\n      for (k=0; k<this.fullOffset.length; k++) {\n        limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;\n      }\n      this.normalize();\n    }\n  };\n\n  /** mostly constant-time, very expensive full reduction.\n   * @memberof sjcl.bn\n   * @this { sjcl.bn }\n   */\n  ppr.fullReduce = function() {\n    var greater, i;\n    // massively above the modulus, may be negative\n    \n    this._strongReduce();\n    // less than twice the modulus, may be negative\n\n    this.addM(this.modulus);\n    this.addM(this.modulus);\n    this.normalize();\n    // probably 2-3x the modulus\n    \n    this._strongReduce();\n    // less than the power of 2.  still may be more than\n    // the modulus\n\n    // HACK: pad out to this length\n    for (i=this.limbs.length; i<this.modOffset; i++) {\n      this.limbs[i] = 0;\n    }\n    \n    // constant-time subtract modulus\n    greater = this.greaterEquals(this.modulus);\n    for (i=0; i<this.limbs.length; i++) {\n      this.limbs[i] -= this.modulus.limbs[i] * greater;\n    }\n    this.cnormalize();\n\n    return this;\n  };\n\n\n  /** @memberof sjcl.bn\n  * @this { sjcl.bn }\n  */\n  ppr.inverse = function() {\n    return (this.power(this.modulus.sub(2)));\n  };\n\n  p.fromBits = sjcl.bn.fromBits;\n\n  return p;\n};\n\n// a small Mersenne prime\nvar sbp = sjcl.bn.pseudoMersennePrime;\nsjcl.bn.prime = {\n  p127: sbp(127, [[0,-1]]),\n\n  // Bernstein's prime for Curve25519\n  p25519: sbp(255, [[0,-19]]),\n\n  // Koblitz primes\n  p192k: sbp(192, [[32,-1],[12,-1],[8,-1],[7,-1],[6,-1],[3,-1],[0,-1]]),\n  p224k: sbp(224, [[32,-1],[12,-1],[11,-1],[9,-1],[7,-1],[4,-1],[1,-1],[0,-1]]),\n  p256k: sbp(256, [[32,-1],[9,-1],[8,-1],[7,-1],[6,-1],[4,-1],[0,-1]]),\n\n  // NIST primes\n  p192: sbp(192, [[0,-1],[64,-1]]),\n  p224: sbp(224, [[0,1],[96,-1]]),\n  p256: sbp(256, [[0,-1],[96,1],[192,1],[224,-1]]),\n  p384: sbp(384, [[0,-1],[32,1],[96,-1],[128,-1]]),\n  p521: sbp(521, [[0,-1]])\n};\n\nsjcl.bn.random = function(modulus, paranoia) {\n  if (typeof modulus !== \"object\") { modulus = new sjcl.bn(modulus); }\n  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();\n  while (true) {\n    // get a sequence whose first digits make sense\n    do {\n      words = sjcl.random.randomWords(l, paranoia);\n      if (words[l-1] < 0) { words[l-1] += 0x100000000; }\n    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));\n    words[l-1] %= m;\n\n    // mask off all the limbs\n    for (i=0; i<l-1; i++) {\n      words[i] &= modulus.radixMask;\n    }\n\n    // check the rest of the digitssj\n    out.limbs = words;\n    if (!out.greaterEquals(modulus)) {\n      return out;\n    }\n  }\n};\n\n/**\n * base class for all ecc operations.\n */\nsjcl.ecc = {};\n\n/**\n * Represents a point on a curve in affine coordinates.\n * @constructor\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n * @param {bigInt} x The x coordinate.\n * @param {bigInt} y The y coordinate.\n */\nsjcl.ecc.point = function(curve,x,y) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\n\n\nsjcl.ecc.point.prototype = {\n  toJac: function() {\n    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));\n  },\n\n  mult: function(k) {\n    return this.toJac().mult(k, this).toAffine();\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k, k2, affine2) {\n    return this.toJac().mult2(k, this, k2, affine2).toAffine();\n  },\n  \n  multiples: function() {\n    var m, i, j;\n    if (this._multiples === undefined) {\n      j = this.toJac().doubl();\n      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];\n      for (i=3; i<16; i++) {\n        j = j.add(this);\n        m.push(j.toAffine());\n      }\n    }\n    return this._multiples;\n  },\n\n  isValid: function() {\n    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));\n  },\n\n  toBits: function() {\n    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());\n  }\n};\n\n/**\n * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which\n * will be converted to bigInts).\n *\n * @constructor\n * @param {bigInt/string} x The x coordinate.\n * @param {bigInt/string} y The y coordinate.\n * @param {bigInt/string} z The z coordinate.\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n */\nsjcl.ecc.pointJac = function(curve, x, y, z) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\nsjcl.ecc.pointJac.prototype = {\n  /**\n   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.\n   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.\n   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. \n   */\n  add: function(T) {\n    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;\n    if (S.curve !== T.curve) {\n      throw(\"sjcl.ecc.add(): Points must be on the same curve to add them!\");\n    }\n\n    if (S.isIdentity) {\n      return T.toJac();\n    } else if (T.isIdentity) {\n      return S;\n    }\n\n    sz2 = S.z.square();\n    c = T.x.mul(sz2).subM(S.x);\n\n    if (c.equals(0)) {\n      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {\n        // same point\n        return S.doubl();\n      } else {\n        // inverses\n        return new sjcl.ecc.pointJac(S.curve);\n      }\n    }\n    \n    d = T.y.mul(sz2.mul(S.z)).subM(S.y);\n    c2 = c.square();\n\n    x1 = d.square();\n    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );\n    x  = x1.subM(x2);\n\n    y1 = S.x.mul(c2).subM(x).mul(d);\n    y2 = S.y.mul(c.square().mul(c));\n    y  = y1.subM(y2);\n\n    z  = S.z.mul(c);\n\n    return new sjcl.ecc.pointJac(this.curve,x,y,z);\n  },\n  \n  /**\n   * doubles this point.\n   * @return {sjcl.ecc.pointJac} The doubled point.\n   */\n  doubl: function() {\n    if (this.isIdentity) { return this; }\n\n    var\n      y2 = this.y.square(),\n      a  = y2.mul(this.x.mul(4)),\n      b  = y2.square().mul(8),\n      z2 = this.z.square(),\n      c  = this.curve.a.toString() == (new sjcl.bn(-3)).toString() ?\n                this.x.sub(z2).mul(3).mul(this.x.add(z2)) :\n                this.x.square().mul(3).add(z2.square().mul(this.curve.a)),\n      x  = c.square().subM(a).subM(a),\n      y  = a.sub(x).mul(c).subM(b),\n      z  = this.y.add(this.y).mul(this.z);\n    return new sjcl.ecc.pointJac(this.curve, x, y, z);\n  },\n\n  /**\n   * Returns a copy of this point converted to affine coordinates.\n   * @return {sjcl.ecc.point} The converted point.\n   */\n  toAffine: function() {\n    if (this.isIdentity || this.z.equals(0)) {\n      return new sjcl.ecc.point(this.curve);\n    }\n    var zi = this.z.inverse(), zi2 = zi.square();\n    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());\n  },\n  \n  /**\n   * Multiply this point by k and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.\n   */\n  mult: function(k, affine) {\n    if (typeof(k) === \"number\") {\n      k = [k];\n    } else if (k.limbs !== undefined) {\n      k = k.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();\n\n    for (i=k.length-1; i>=0; i--) {\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k1, affine, k2, affine2) {\n    if (typeof(k1) === \"number\") {\n      k1 = [k1];\n    } else if (k1.limbs !== undefined) {\n      k1 = k1.normalize().limbs;\n    }\n    \n    if (typeof(k2) === \"number\") {\n      k2 = [k2];\n    } else if (k2.limbs !== undefined) {\n      k2 = k2.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),\n        m2 = affine2.multiples(), l1, l2;\n\n    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {\n      l1 = k1[i] | 0;\n      l2 = k2[i] | 0;\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n\n  isValid: function() {\n    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);\n    return this.y.square().equals(\n             this.curve.b.mul(z6).add(this.x.mul(\n               this.curve.a.mul(z4).add(this.x.square()))));\n  }\n};\n\n/**\n * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.\n *\n * @constructor\n * @param {bigInt} p The prime modulus.\n * @param {bigInt} r The prime order of the curve.\n * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).\n * @param {bigInt} x The x coordinate of a base point of the curve.\n * @param {bigInt} y The y coordinate of a base point of the curve.\n */\nsjcl.ecc.curve = function(Field, r, a, b, x, y) {\n  this.field = Field;\n  this.r = new sjcl.bn(r);\n  this.a = new Field(a);\n  this.b = new Field(b);\n  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));\n};\n\nsjcl.ecc.curve.prototype.fromBits = function (bits) {\n  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,\n      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),\n                             this.field.fromBits(w.bitSlice(bits, l, 2*l)));\n  if (!p.isValid()) {\n    throw new sjcl.exception.corrupt(\"not on the curve!\");\n  }\n  return p;\n};\n\nsjcl.ecc.curves = {\n  c192: new sjcl.ecc.curve(\n    sjcl.bn.prime.p192,\n    \"0xffffffffffffffffffffffff99def836146bc9b1b4d22831\",\n    -3,\n    \"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\",\n    \"0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\",\n    \"0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"),\n\n  c224: new sjcl.ecc.curve(\n    sjcl.bn.prime.p224,\n    \"0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d\",\n    -3,\n    \"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\",\n    \"0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\",\n    \"0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\"),\n\n  c256: new sjcl.ecc.curve(\n    sjcl.bn.prime.p256,\n    \"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\",\n    -3,\n    \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",\n    \"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",\n    \"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n\n  c384: new sjcl.ecc.curve(\n    sjcl.bn.prime.p384,\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\",\n    -3,\n    \"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\",\n    \"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\",\n    \"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\"),\n\n  k192: new sjcl.ecc.curve(\n    sjcl.bn.prime.p192k,\n    \"0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d\",\n    0,\n    3,\n    \"0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d\",\n    \"0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d\"),\n\n  k224: new sjcl.ecc.curve(\n    sjcl.bn.prime.p224k,\n    \"0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7\",\n    0,\n    5,\n    \"0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c\",\n    \"0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5\"),\n\n  k256: new sjcl.ecc.curve(\n    sjcl.bn.prime.p256k,\n    \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\n    0,\n    7,\n    \"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n    \"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n\n};\n\n/** our basicKey classes\n*/\nsjcl.ecc.basicKey = {\n  /** ecc publicKey. \n  * @constructor\n  * @param {curve} curve the elliptic curve\n  * @param {point} point the point on the curve\n  */\n  publicKey: function(curve, point) {\n    this._curve = curve;\n    this._curveBitLength = curve.r.bitLength();\n    if (point instanceof Array) {\n      this._point = curve.fromBits(point);\n    } else {\n      this._point = point;\n    }\n\n    /** get this keys point data\n    * @return x and y as bitArrays\n    */\n    this.get = function() {\n      var pointbits = this._point.toBits();\n      var len = sjcl.bitArray.bitLength(pointbits);\n      var x = sjcl.bitArray.bitSlice(pointbits, 0, len/2);\n      var y = sjcl.bitArray.bitSlice(pointbits, len/2);\n      return { x: x, y: y };\n    };\n  },\n\n  /** ecc secretKey\n  * @constructor\n  * @param {curve} curve the elliptic curve\n  * @param exponent\n  */\n  secretKey: function(curve, exponent) {\n    this._curve = curve;\n    this._curveBitLength = curve.r.bitLength();\n    this._exponent = exponent;\n\n    /** get this keys exponent data\n    * @return {bitArray} exponent\n    */\n    this.get = function () {\n      return this._exponent.toBits();\n    };\n  }\n};\n\n/** @private */\nsjcl.ecc.basicKey.generateKeys = function(cn) {\n  return function generateKeys(curve, paranoia, sec) {\n    curve = curve || 256;\n\n    if (typeof curve === \"number\") {\n      curve = sjcl.ecc.curves['c'+curve];\n      if (curve === undefined) {\n        throw new sjcl.exception.invalid(\"no such curve\");\n      }\n    }\n    sec = sec || sjcl.bn.random(curve.r, paranoia);\n\n    var pub = curve.G.mult(sec);\n    return { pub: new sjcl.ecc[cn].publicKey(curve, pub),\n             sec: new sjcl.ecc[cn].secretKey(curve, sec) };\n  };\n};\n\n/** elGamal keys */\nsjcl.ecc.elGamal = {\n  /** generate keys\n  * @function\n  * @param curve\n  * @param {int} paranoia Paranoia for generation (default 6)\n  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n  */\n  generateKeys: sjcl.ecc.basicKey.generateKeys(\"elGamal\"),\n  /** elGamal publicKey. \n  * @constructor\n  * @augments sjcl.ecc.basicKey.publicKey\n  */\n  publicKey: function (curve, point) {\n    sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n  },\n  /** elGamal secretKey\n  * @constructor\n  * @augments sjcl.ecc.basicKey.secretKey\n  */\n  secretKey: function (curve, exponent) {\n    sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n  }\n};\n\nsjcl.ecc.elGamal.publicKey.prototype = {\n  /** Kem function of elGamal Public Key\n  * @param paranoia paranoia to use for randomization.\n  * @return {object} key and tag. unkem(tag) with the corresponding secret key results in the key returned.\n  */\n  kem: function(paranoia) {\n    var sec = sjcl.bn.random(this._curve.r, paranoia),\n        tag = this._curve.G.mult(sec).toBits(),\n        key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());\n    return { key: key, tag: tag };\n  }\n};\n\nsjcl.ecc.elGamal.secretKey.prototype = {\n  /** UnKem function of elGamal Secret Key\n  * @param {bitArray} tag The Tag to decrypt.\n  * @return {bitArray} decrypted key.\n  */\n  unkem: function(tag) {\n    return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());\n  },\n\n  /** Diffie-Hellmann function\n  * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with\n  * @return {bitArray} diffie-hellmann result for this key combination.\n  */\n  dh: function(pk) {\n    return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());\n  }\n};\n\n/** ecdsa keys */\nsjcl.ecc.ecdsa = {\n  /** generate keys\n  * @function\n  * @param curve\n  * @param {int} paranoia Paranoia for generation (default 6)\n  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n  */\n  generateKeys: sjcl.ecc.basicKey.generateKeys(\"ecdsa\")\n};\n\n/** ecdsa publicKey. \n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.publicKey = function (curve, point) {\n  sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n};\n\n/** specific functions for ecdsa publicKey. */\nsjcl.ecc.ecdsa.publicKey.prototype = {\n  /** Diffie-Hellmann function\n  * @param {bitArray} hash hash to verify. \n  * @param {bitArray} rs signature bitArray.\n  * @param {boolean}  fakeLegacyVersion use old legacy version\n  */\n  verify: function(hash, rs, fakeLegacyVersion) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n    var w = sjcl.bitArray,\n        R = this._curve.r,\n        l = this._curveBitLength,\n        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),\n        ss = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),\n        s = fakeLegacyVersion ? ss : ss.inverseMod(R),\n        hG = sjcl.bn.fromBits(hash).mul(s).mod(R),\n        hA = r.mul(s).mod(R),\n        r2 = this._curve.G.mult2(hG, hA, this._point).x;\n    if (r.equals(0) || ss.equals(0) || r.greaterEquals(R) || ss.greaterEquals(R) || !r2.equals(r)) {\n      if (fakeLegacyVersion === undefined) {\n        return this.verify(hash, rs, true);\n      } else {\n        throw (new sjcl.exception.corrupt(\"signature didn't check out\"));\n      }\n    }\n    return true;\n  }\n};\n\n/** ecdsa secretKey\n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.secretKey = function (curve, exponent) {\n  sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n};\n\n/** specific functions for ecdsa secretKey. */\nsjcl.ecc.ecdsa.secretKey.prototype = {\n  /** Diffie-Hellmann function\n  * @param {bitArray} hash hash to sign. \n  * @param {int} paranoia paranoia for random number generation\n  * @param {boolean} fakeLegacyVersion use old legacy version\n  */\n  sign: function(hash, paranoia, fakeLegacyVersion, fixedKForTesting) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n    var R  = this._curve.r,\n        l  = R.bitLength(),\n        k  = fixedKForTesting || sjcl.bn.random(R.sub(1), paranoia).add(1),\n        r  = this._curve.G.mult(k).x.mod(R),\n        ss = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)),\n        s  = fakeLegacyVersion ? ss.inverseMod(R).mul(k).mod(R)\n             : ss.mul(k.inverseMod(R)).mod(R);\n    return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n  }\n};",
              "globals": {
                "sjcl": {
                  "type": "assign"
                },
                "module": {
                  "type": "typeof"
                },
                "Math": {
                  "type": "reference"
                },
                "String": {
                  "type": "reference"
                },
                "decodeURIComponent": {
                  "type": "call"
                },
                "escape": {
                  "type": "call"
                },
                "unescape": {
                  "type": "call"
                },
                "encodeURIComponent": {
                  "type": "call"
                },
                "parseInt": {
                  "type": "call"
                },
                "Object": {
                  "type": "reference"
                },
                "window": {
                  "type": "reference"
                },
                "document": {
                  "type": "reference"
                },
                "require": {
                  "type": "call"
                },
                "console": {
                  "type": "reference"
                },
                "sbp": {
                  "type": "assign"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "crypto": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = '../node_modules/sjcl';",
              "code": "function(require, exports, module) {var __dirname = '../node_modules/sjcl';\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/** @namespace The Stanford Javascript Crypto Library, top-level namespace. */\nvar sjcl = {\n  /** @namespace Symmetric ciphers. */\n  cipher: {},\n\n  /** @namespace Hash functions.  Right now only SHA256 is implemented. */\n  hash: {},\n\n  /** @namespace Key exchange functions.  Right now only SRP is implemented. */\n  keyexchange: {},\n  \n  /** @namespace Block cipher modes of operation. */\n  mode: {},\n\n  /** @namespace Miscellaneous.  HMAC and PBKDF2. */\n  misc: {},\n  \n  /**\n   * @namespace Bit array encoders and decoders.\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /** @namespace Exceptions. */\n  exception: {\n    /** @constructor Ciphertext is corrupt. */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @constructor Invalid parameter. */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /** @constructor Bug or missing feature in SJCL. @constructor */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /** @constructor Something isn't ready. */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\nif(typeof module !== 'undefined' && module.exports){\n  module.exports = sjcl;\n}\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n *\n * @class Advanced Encryption Standard (low-level interface)\n */\nsjcl.cipher.aes = function (key) {\n  if (!this._tables[0][0][0]) {\n    this._precompute();\n  }\n  \n  var i, j, tmp,\n    encKey, decKey,\n    sbox = this._tables[0][4], decTable = this._tables[1],\n    keyLen = key.length, rcon = 1;\n  \n  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n    throw new sjcl.exception.invalid(\"invalid aes key size\");\n  }\n  \n  this._key = [encKey = key.slice(0), decKey = []];\n  \n  // schedule encryption keys\n  for (i = keyLen; i < 4 * keyLen + 28; i++) {\n    tmp = encKey[i-1];\n    \n    // apply sbox\n    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {\n      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];\n      \n      // shift rows and add rcon\n      if (i%keyLen === 0) {\n        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;\n        rcon = rcon<<1 ^ (rcon>>7)*283;\n      }\n    }\n    \n    encKey[i] = encKey[i-keyLen] ^ tmp;\n  }\n  \n  // schedule decryption keys\n  for (j = 0; i; j++, i--) {\n    tmp = encKey[j&3 ? i : i - 4];\n    if (i<=4 || j<4) {\n      decKey[j] = tmp;\n    } else {\n      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^\n                  decTable[1][sbox[tmp>>16  & 255]] ^\n                  decTable[2][sbox[tmp>>8   & 255]] ^\n                  decTable[3][sbox[tmp      & 255]];\n    }\n  }\n};\n\nsjcl.cipher.aes.prototype = {\n  // public\n  /* Something like this might appear here eventually\n  name: \"AES\",\n  blockSize: 4,\n  keySizes: [4,6,8],\n  */\n  \n  /**\n   * Encrypt an array of 4 big-endian words.\n   * @param {Array} data The plaintext.\n   * @return {Array} The ciphertext.\n   */\n  encrypt:function (data) { return this._crypt(data,0); },\n  \n  /**\n   * Decrypt an array of 4 big-endian words.\n   * @param {Array} data The ciphertext.\n   * @return {Array} The plaintext.\n   */\n  decrypt:function (data) { return this._crypt(data,1); },\n  \n  /**\n   * The expanded S-box and inverse S-box tables.  These will be computed\n   * on the client so that we don't have to send them down the wire.\n   *\n   * There are two tables, _tables[0] is for encryption and\n   * _tables[1] is for decryption.\n   *\n   * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n   * last (_tables[01][4]) is the S-box itself.\n   *\n   * @private\n   */\n  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],\n\n  /**\n   * Expand the S-box tables.\n   *\n   * @private\n   */\n  _precompute: function () {\n   var encTable = this._tables[0], decTable = this._tables[1],\n       sbox = encTable[4], sboxInv = decTable[4],\n       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;\n\n    // Compute double and third tables\n   for (i = 0; i < 256; i++) {\n     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;\n   }\n   \n   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n     // Compute sbox\n     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;\n     s = s>>8 ^ s&255 ^ 99;\n     sbox[x] = s;\n     sboxInv[s] = x;\n     \n     // Compute MixColumns\n     x8 = d[x4 = d[x2 = d[x]]];\n     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;\n     tEnc = d[s]*0x101 ^ s*0x1010100;\n     \n     for (i = 0; i < 4; i++) {\n       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;\n       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;\n     }\n   }\n   \n   // Compactify.  Considerable speedup on Firefox.\n   for (i = 0; i < 5; i++) {\n     encTable[i] = encTable[i].slice(0);\n     decTable[i] = decTable[i].slice(0);\n   }\n  },\n  \n  /**\n   * Encryption and decryption core.\n   * @param {Array} input Four words to be encrypted or decrypted.\n   * @param dir The direction, 0 for encrypt and 1 for decrypt.\n   * @return {Array} The four encrypted or decrypted words.\n   * @private\n   */\n  _crypt:function (input, dir) {\n    if (input.length !== 4) {\n      throw new sjcl.exception.invalid(\"invalid aes block size\");\n    }\n    \n    var key = this._key[dir],\n        // state variables a,b,c,d are loaded with pre-whitened data\n        a = input[0]           ^ key[0],\n        b = input[dir ? 3 : 1] ^ key[1],\n        c = input[2]           ^ key[2],\n        d = input[dir ? 1 : 3] ^ key[3],\n        a2, b2, c2,\n        \n        nInnerRounds = key.length/4 - 2,\n        i,\n        kIndex = 4,\n        out = [0,0,0,0],\n        table = this._tables[dir],\n        \n        // load up the tables\n        t0    = table[0],\n        t1    = table[1],\n        t2    = table[2],\n        t3    = table[3],\n        sbox  = table[4];\n \n    // Inner rounds.  Cribbed from OpenSSL.\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a=a2; b=b2; c=c2;\n    }\n        \n    // Last round.\n    for (i = 0; i < 4; i++) {\n      out[dir ? 3&-i : i] =\n        sbox[a>>>24      ]<<24 ^ \n        sbox[b>>16  & 255]<<16 ^\n        sbox[c>>8   & 255]<<8  ^\n        sbox[d      & 255]     ^\n        key[kIndex++];\n      a2=a; a=b; b=c; c=d; d=a2;\n    }\n    \n    return out;\n  }\n};\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Arrays of bits, encoded as arrays of Numbers.\n *\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} length The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n/** @namespace UTF-8 strings */\nsjcl.codec.utf8String = {\n  /** Convert from a bitArray to a UTF-8 string. */\n  fromBits: function (arr) {\n    var out = \"\", bl = sjcl.bitArray.bitLength(arr), i, tmp;\n    for (i=0; i<bl/8; i++) {\n      if ((i&3) === 0) {\n        tmp = arr[i/4];\n      }\n      out += String.fromCharCode(tmp >>> 24);\n      tmp <<= 8;\n    }\n    return decodeURIComponent(escape(out));\n  },\n  \n  /** Convert from a UTF-8 string to a bitArray. */\n  toBits: function (str) {\n    str = unescape(encodeURIComponent(str));\n    var out = [], i, tmp=0;\n    for (i=0; i<str.length; i++) {\n      tmp = tmp << 8 | str.charCodeAt(i);\n      if ((i&3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n    if (i&3) {\n      out.push(sjcl.bitArray.partial(8*(i&3), tmp));\n    }\n    return out;\n  }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Hexadecimal */\nsjcl.codec.hex = {\n  /** Convert from a bitArray to a hex string. */\n  fromBits: function (arr) {\n    var out = \"\", i;\n    for (i=0; i<arr.length; i++) {\n      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);\n    }\n    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, \"$1 \");\n  },\n  /** Convert from a hex string to a bitArray. */\n  toBits: function (str) {\n    var i, out=[], len;\n    str = str.replace(/\\s|0x/g, \"\");\n    len = str.length;\n    str = str + \"00000000\";\n    for (i=0; i<str.length; i+=8) {\n      out.push(parseInt(str.substr(i,8),16)^0);\n    }\n    return sjcl.bitArray.clamp(out, len*4);\n  }\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace Base64 encoding/decoding */\nsjcl.codec.base64 = {\n  /** The base64 alphabet.\n   * @private\n   */\n  _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  \n  /** Convert from a bitArray to a base64 string. */\n  fromBits: function (arr, _noEquals, _url) {\n    var out = \"\", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; out.length * 6 <= bl; ) {\n      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);\n      if (bits < 6) {\n        ta = arr[i] << (6-bits);\n        bits += 26;\n        i++;\n      } else {\n        ta <<= 6;\n        bits -= 6;\n      }\n    }\n    while ((out.length & 3) && !_noEquals) { out += \"=\"; }\n    return out;\n  },\n  \n  /** Convert from a base64 string to a bitArray */\n  toBits: function(str, _url) {\n    str = str.replace(/\\s|=/g,'');\n    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;\n    if (_url) {\n      c = c.substr(0,62) + '-_';\n    }\n    for (i=0; i<str.length; i++) {\n      x = c.indexOf(str.charAt(i));\n      if (x < 0) {\n        throw new sjcl.exception.invalid(\"this isn't base64!\");\n      }\n      if (bits > 26) {\n        bits -= 26;\n        out.push(ta ^ x>>>bits);\n        ta  = x << (32-bits);\n      } else {\n        bits += 6;\n        ta ^= x << (32-bits);\n      }\n    }\n    if (bits&56) {\n      out.push(sjcl.bitArray.partial(bits&56, ta, 1));\n    }\n    return out;\n  }\n};\n\nsjcl.codec.base64url = {\n  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },\n  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n * @class Secure Hash Algorithm, 256 bits.\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    for (i = 512+ol & -512; i <= nl; i+= 512) {\n      this._block(b.splice(0,16));\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    outer: for (; i<64; prime++) {\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          // not a prime\n          continue outer;\n        }\n      }\n      \n      if (i<8) {\n        this._init[i] = frac(Math.pow(prime, 1/2));\n      }\n      this._key[i] = frac(Math.pow(prime, 1/3));\n      i++;\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {  \n    var i, tmp, a, b,\n      w = words.slice(0),\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n/** @fileOverview CCM mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace CTR mode with CBC MAC. */\nsjcl.mode.ccm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ccm\",\n  \n  /** Encrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function(prf, plaintext, iv, adata, tlen) {\n    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;\n    tlen = tlen || 64;\n    adata = adata || [];\n    \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // compute the tag\n    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n    \n    // encrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    return w.concat(out.data, out.tag);\n  },\n  \n  /** Decrypt in CCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [[]] adata The authenticated data.\n   * @param {Number} [64] tlen the desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function(prf, ciphertext, iv, adata, tlen) {\n    tlen = tlen || 64;\n    adata = adata || [];\n    var L,\n        w=sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(ciphertext), \n        out = w.clamp(ciphertext, ol - tlen),\n        tag = w.bitSlice(ciphertext, ol - tlen), tag2;\n    \n\n    ol = (ol - tlen) / 8;\n        \n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n    \n    // compute the length of the length\n    for (L=2; L<4 && ol >>> 8*L; L++) {}\n    if (L < 15 - ivl) { L = 15-ivl; }\n    iv = w.clamp(iv,8*(15-L));\n    \n    // decrypt\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    \n    // check the tag\n    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n    if (!w.equal(out.tag, tag2)) {\n      throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    }\n    \n    return out.data;\n  },\n\n  /* Compute the (unencrypted) authentication tag, according to the CCM specification\n   * @param {Object} prf The pseudorandom function.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} adata The authenticated data.\n   * @param {Number} tlen the desired tag length, in bits.\n   * @return {bitArray} The tag, but not yet encrypted.\n   * @private\n   */\n  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {\n    // compute B[0]\n    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;\n\n    tlen /= 8;\n  \n    // check tag length and message length\n    if (tlen % 2 || tlen < 4 || tlen > 16) {\n      throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    }\n  \n    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {\n      // I don't want to deal with extracting high words from doubles.\n      throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    }\n\n    // mac the flags\n    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];\n\n    // mac the iv and length\n    mac = w.concat(mac, iv);\n    mac[3] |= w.bitLength(plaintext)/8;\n    mac = prf.encrypt(mac);\n    \n  \n    if (adata.length) {\n      // mac the associated data.  start with its length...\n      tmp = w.bitLength(adata)/8;\n      if (tmp <= 0xFEFF) {\n        macData = [w.partial(16, tmp)];\n      } else if (tmp <= 0xFFFFFFFF) {\n        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);\n      } // else ...\n    \n      // mac the data itself\n      macData = w.concat(macData, adata);\n      for (i=0; i<macData.length; i += 4) {\n        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));\n      }\n    }\n  \n    // mac the plaintext\n    for (i=0; i<plaintext.length; i+=4) {\n      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));\n    }\n\n    return w.clamp(mac, tlen * 8);\n  },\n\n  /** CCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.\n   * May mutate its arguments.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} tag The authentication tag.\n   * @param {Number} tlen The length of th etag, in bits.\n   * @param {Number} L The CCM L value.\n   * @return {Object} An object with data and tag, the en/decryption of data and tag values.\n   * @private\n   */\n  _ctrMode: function(prf, data, iv, tag, tlen, L) {\n    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data);\n\n    // start the ctr\n    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);\n    \n    // en/decrypt the tag\n    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);\n  \n    // en/decrypt the data\n    if (!l) { return {tag:tag, data:[]}; }\n    \n    for (i=0; i<l; i+=4) {\n      ctr[3]++;\n      enc = prf.encrypt(ctr);\n      data[i]   ^= enc[0];\n      data[i+1] ^= enc[1];\n      data[i+2] ^= enc[2];\n      data[i+3] ^= enc[3];\n    }\n    return { tag:tag, data:w.clamp(data,bl) };\n  }\n};\n/** @fileOverview OCB 2.0 implementation\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** @namespace\n * Phil Rogaway's Offset CodeBook mode, version 2.0.\n * May be covered by US and international patents.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\nsjcl.mode.ocb2 = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"ocb2\",\n  \n  /** Encrypt in OCB mode, version 2.0.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param [false] premac 1 if the authentication data is pre-macced with PMAC.\n   * @return The encrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   */\n  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n    tlen  = tlen || 64;\n  \n    for (i=0; i+4 < plaintext.length; i+=4) {\n      /* Encrypt a non-final block */\n      bi = plaintext.slice(i,i+4);\n      checksum = xor(checksum, bi);\n      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));\n      delta = times2(delta);\n    }\n    \n    /* Chop out the final block */\n    bi = plaintext.slice(i);\n    bl = w.bitLength(bi);\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));\n    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));\n  },\n  \n  /** Decrypt in OCB mode.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=64] the desired tag length, in bits.\n   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.\n   * @return The decrypted data, an array of bytes.\n   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.\n   * @throws {sjcl.exception.corrupt} if if the message is corrupt.\n   */\n  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {\n    if (sjcl.bitArray.bitLength(iv) !== 128) {\n      throw new sjcl.exception.invalid(\"ocb iv must be 128 bits\");\n    }\n    tlen  = tlen || 64;\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = times2(prp.encrypt(iv)),\n        bi, bl,\n        len = sjcl.bitArray.bitLength(ciphertext) - tlen,\n        output = [],\n        pad;\n        \n    adata = adata || [];\n  \n    for (i=0; i+4 < len/32; i+=4) {\n      /* Decrypt a non-final block */\n      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));\n      checksum = xor(checksum, bi);\n      output = output.concat(bi);\n      delta = times2(delta);\n    }\n    \n    /* Chop out and decrypt the final block */\n    bl = len-i*32;\n    pad = prp.encrypt(xor(delta,[0,0,0,bl]));\n    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));\n    \n    /* Checksum the final block, and finalize the checksum */\n    checksum = xor(checksum, bi);\n    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));\n    \n    /* MAC the header */\n    if (adata.length) {\n      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));\n    }\n    \n    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {\n      throw new sjcl.exception.corrupt(\"ocb: tag doesn't match\");\n    }\n    \n    return output.concat(w.clamp(bi,bl));\n  },\n  \n  /** PMAC authentication for OCB associated data.\n   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.\n   * @param {bitArray} adata The authenticated data.\n   */\n  pmac: function(prp, adata) {\n    var i,\n        times2 = sjcl.mode.ocb2._times2,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        checksum = [0,0,0,0],\n        delta = prp.encrypt([0,0,0,0]),\n        bi;\n        \n    delta = xor(delta,times2(times2(delta)));\n \n    for (i=0; i+4<adata.length; i+=4) {\n      delta = times2(delta);\n      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));\n    }\n    \n    bi = adata.slice(i);\n    if (w.bitLength(bi) < 128) {\n      delta = xor(delta,times2(delta));\n      bi = w.concat(bi,[0x80000000|0,0,0,0]);\n    }\n    checksum = xor(checksum, bi);\n    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));\n  },\n  \n  /** Double a block of words, OCB style.\n   * @private\n   */\n  _times2: function(x) {\n    return [x[0]<<1 ^ x[1]>>>31,\n            x[1]<<1 ^ x[2]>>>31,\n            x[2]<<1 ^ x[3]>>>31,\n            x[3]<<1 ^ (x[0]>>>31)*0x87];\n  }\n};\n/** @fileOverview GCM mode implementation.\n *\n * @author Juho Vähä-Herttua\n */\n\n/** @namespace Galois/Counter mode. */\nsjcl.mode.gcm = {\n  /** The name of the mode.\n   * @constant\n   */\n  name: \"gcm\",\n  \n  /** Encrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} plaintext The plaintext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The encrypted data, an array of bytes.\n   */\n  encrypt: function (prf, plaintext, iv, adata, tlen) {\n    var out, data = plaintext.slice(0), w=sjcl.bitArray;\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // encrypt and tag\n    out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);\n\n    return w.concat(out.data, out.tag);\n  },\n  \n  /** Decrypt in GCM mode.\n   * @static\n   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n   * @param {bitArray} ciphertext The ciphertext data.\n   * @param {bitArray} iv The initialization value.\n   * @param {bitArray} [adata=[]] The authenticated data.\n   * @param {Number} [tlen=128] The desired tag length, in bits.\n   * @return {bitArray} The decrypted data.\n   */\n  decrypt: function (prf, ciphertext, iv, adata, tlen) {\n    var out, data = ciphertext.slice(0), tag, w=sjcl.bitArray, l=w.bitLength(data);\n    tlen = tlen || 128;\n    adata = adata || [];\n\n    // Slice tag out of data\n    if (tlen <= l) {\n      tag = w.bitSlice(data, l-tlen);\n      data = w.bitSlice(data, 0, l-tlen);\n    } else {\n      tag = data;\n      data = [];\n    }\n\n    // decrypt and tag\n    out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);\n\n    if (!w.equal(out.tag, tag)) {\n      throw new sjcl.exception.corrupt(\"gcm: tag doesn't match\");\n    }\n    return out.data;\n  },\n\n  /* Compute the galois multiplication of X and Y\n   * @private\n   */\n  _galoisMultiply: function (x, y) {\n    var i, j, xi, Zi, Vi, lsb_Vi, w=sjcl.bitArray, xor=w._xor4;\n\n    Zi = [0,0,0,0];\n    Vi = y.slice(0);\n\n    // Block size is 128 bits, run 128 times to get Z_128\n    for (i=0; i<128; i++) {\n      xi = (x[Math.floor(i/32)] & (1 << (31-i%32))) !== 0;\n      if (xi) {\n        // Z_i+1 = Z_i ^ V_i\n        Zi = xor(Zi, Vi);\n      }\n\n      // Store the value of LSB(V_i)\n      lsb_Vi = (Vi[3] & 1) !== 0;\n\n      // V_i+1 = V_i >> 1\n      for (j=3; j>0; j--) {\n        Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);\n      }\n      Vi[0] = Vi[0] >>> 1;\n\n      // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R\n      if (lsb_Vi) {\n        Vi[0] = Vi[0] ^ (0xe1 << 24);\n      }\n    }\n    return Zi;\n  },\n\n  _ghash: function(H, Y0, data) {\n    var Yi, i, l = data.length;\n\n    Yi = Y0.slice(0);\n    for (i=0; i<l; i+=4) {\n      Yi[0] ^= 0xffffffff&data[i];\n      Yi[1] ^= 0xffffffff&data[i+1];\n      Yi[2] ^= 0xffffffff&data[i+2];\n      Yi[3] ^= 0xffffffff&data[i+3];\n      Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);\n    }\n    return Yi;\n  },\n\n  /** GCM CTR mode.\n   * Encrypt or decrypt data and tag with the prf in GCM-style CTR mode.\n   * @param {Boolean} encrypt True if encrypt, false if decrypt.\n   * @param {Object} prf The PRF.\n   * @param {bitArray} data The data to be encrypted or decrypted.\n   * @param {bitArray} iv The initialization vector.\n   * @param {bitArray} adata The associated data to be tagged.\n   * @param {Number} tlen The length of the tag, in bits.\n   */\n  _ctrMode: function(encrypt, prf, data, adata, iv, tlen) {\n    var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w=sjcl.bitArray;\n\n    // Calculate data lengths\n    l = data.length;\n    bl = w.bitLength(data);\n    abl = w.bitLength(adata);\n    ivbl = w.bitLength(iv);\n\n    // Calculate the parameters\n    H = prf.encrypt([0,0,0,0]);\n    if (ivbl === 96) {\n      J0 = iv.slice(0);\n      J0 = w.concat(J0, [1]);\n    } else {\n      J0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], iv);\n      J0 = sjcl.mode.gcm._ghash(H, J0, [0,0,Math.floor(ivbl/0x100000000),ivbl&0xffffffff]);\n    }\n    S0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], adata);\n\n    // Initialize ctr and tag\n    ctr = J0.slice(0);\n    tag = S0.slice(0);\n\n    // If decrypting, calculate hash\n    if (!encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Encrypt all the data\n    for (i=0; i<l; i+=4) {\n       ctr[3]++;\n       enc = prf.encrypt(ctr);\n       data[i]   ^= enc[0];\n       data[i+1] ^= enc[1];\n       data[i+2] ^= enc[2];\n       data[i+3] ^= enc[3];\n    }\n    data = w.clamp(data, bl);\n\n    // If encrypting, calculate hash\n    if (encrypt) {\n      tag = sjcl.mode.gcm._ghash(H, S0, data);\n    }\n\n    // Calculate last block from bit lengths, ugly because bitwise operations are 32-bit\n    last = [\n      Math.floor(abl/0x100000000), abl&0xffffffff,\n      Math.floor(bl/0x100000000), bl&0xffffffff\n    ];\n\n    // Calculate the final tag block\n    tag = sjcl.mode.gcm._ghash(H, tag, last);\n    enc = prf.encrypt(J0);\n    tag[0] ^= enc[0];\n    tag[1] ^= enc[1];\n    tag[2] ^= enc[2];\n    tag[3] ^= enc[3];\n\n    return { tag:w.bitSlice(tag, 0, tlen), data:data };\n  }\n};\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};/** @fileOverview Password-based key-derivation function, version 2.0.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Password-Based Key-Derivation Function, version 2.0.\n *\n * Generate keys from passwords using PBKDF2-HMAC-SHA256.\n *\n * This is the method specified by RSA's PKCS #5 standard.\n *\n * @param {bitArray|String} password  The password.\n * @param {bitArray|String} salt The salt.  Should have lots of entropy.\n * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.\n * @param {Number} [length] The length of the derived key.  Defaults to the\n                            output size of the hash function.\n * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.\n * @return {bitArray} the derived key.\n */\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n  count = count || 1000;\n  \n  if (length < 0 || count < 0) {\n    throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  }\n  \n  if (typeof password === \"string\") {\n    password = sjcl.codec.utf8String.toBits(password);\n  }\n  \n  if (typeof salt === \"string\") {\n    salt = sjcl.codec.utf8String.toBits(salt);\n  }\n  \n  Prff = Prff || sjcl.misc.hmac;\n  \n  var prf = new Prff(password),\n      u, ui, i, j, k, out = [], b = sjcl.bitArray;\n\n  for (k = 1; 32 * out.length < (length || 1); k++) {\n    u = ui = prf.encrypt(b.concat(salt,[k]));\n    \n    for (i=1; i<count; i++) {\n      ui = prf.encrypt(ui);\n      for (j=0; j<ui.length; j++) {\n        u[j] ^= ui[j];\n      }\n    }\n    \n    out = out.concat(u);\n  }\n\n  if (length) { out = b.clamp(out, length); }\n\n  return out;\n};\n/** @fileOverview Random number generator.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Michael Brooks\n */\n\n/** @constructor\n * @class Random number generator\n * @description\n * <b>Use sjcl.random as a singleton for this class!</b>\n * <p>\n * This random number generator is a derivative of Ferguson and Schneier's\n * generator Fortuna.  It collects entropy from various events into several\n * pools, implemented by streaming SHA-256 instances.  It differs from\n * ordinary Fortuna in a few ways, though.\n * </p>\n *\n * <p>\n * Most importantly, it has an entropy estimator.  This is present because\n * there is a strong conflict here between making the generator available\n * as soon as possible, and making sure that it doesn't \"run on empty\".\n * In Fortuna, there is a saved state file, and the system is likely to have\n * time to warm up.\n * </p>\n *\n * <p>\n * Second, because users are unlikely to stay on the page for very long,\n * and to speed startup time, the number of pools increases logarithmically:\n * a new pool is created when the previous one is actually used for a reseed.\n * This gives the same asymptotic guarantees as Fortuna, but gives more\n * entropy to early reseeds.\n * </p>\n *\n * <p>\n * The entire mechanism here feels pretty klunky.  Furthermore, there are\n * several improvements that should be made, including support for\n * dedicated cryptographic functions that may be present in some browsers;\n * state files in local storage; cookies containing randomness; etc.  So\n * look for improvements in future versions.\n * </p>\n */\nsjcl.prng = function(defaultParanoia) {\n  \n  /* private */\n  this._pools                   = [new sjcl.hash.sha256()];\n  this._poolEntropy             = [0];\n  this._reseedCount             = 0;\n  this._robins                  = {};\n  this._eventId                 = 0;\n  \n  this._collectorIds            = {};\n  this._collectorIdNext         = 0;\n  \n  this._strength                = 0;\n  this._poolStrength            = 0;\n  this._nextReseed              = 0;\n  this._key                     = [0,0,0,0,0,0,0,0];\n  this._counter                 = [0,0,0,0];\n  this._cipher                  = undefined;\n  this._defaultParanoia         = defaultParanoia;\n  \n  /* event listener stuff */\n  this._collectorsStarted       = false;\n  this._callbacks               = {progress: {}, seeded: {}};\n  this._callbackI               = 0;\n  \n  /* constants */\n  this._NOT_READY               = 0;\n  this._READY                   = 1;\n  this._REQUIRES_RESEED         = 2;\n\n  this._MAX_WORDS_PER_BURST     = 65536;\n  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];\n  this._MILLISECONDS_PER_RESEED = 30000;\n  this._BITS_PER_RESEED         = 80;\n};\n \nsjcl.prng.prototype = {\n  /** Generate several random words, and return them in an array.\n   * A word consists of 32 bits (4 bytes)\n   * @param {Number} nwords The number of words to generate.\n   */\n  randomWords: function (nwords, paranoia) {\n    var out = [], i, readiness = this.isReady(paranoia), g;\n  \n    if (readiness === this._NOT_READY) {\n      throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    } else if (readiness & this._REQUIRES_RESEED) {\n      this._reseedFromPools(!(readiness & this._READY));\n    }\n  \n    for (i=0; i<nwords; i+= 4) {\n      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {\n        this._gate();\n      }\n   \n      g = this._gen4words();\n      out.push(g[0],g[1],g[2],g[3]);\n    }\n    this._gate();\n  \n    return out.slice(0,nwords);\n  },\n  \n  setDefaultParanoia: function (paranoia, allowZeroParanoia) {\n    if (paranoia === 0 && allowZeroParanoia !== \"Setting paranoia=0 will ruin your security; use it only for testing\") {\n      throw \"Setting paranoia=0 will ruin your security; use it only for testing\";\n    }\n\n    this._defaultParanoia = paranoia;\n  },\n  \n  /**\n   * Add entropy to the pools.\n   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string\n   * @param {Number} estimatedEntropy The estimated entropy of data, in bits\n   * @param {String} source The source of the entropy, eg \"mouse\"\n   */\n  addEntropy: function (data, estimatedEntropy, source) {\n    source = source || \"user\";\n  \n    var id,\n      i, tmp,\n      t = (new Date()).valueOf(),\n      robin = this._robins[source],\n      oldReady = this.isReady(), err = 0, objName;\n      \n    id = this._collectorIds[source];\n    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }\n      \n    if (robin === undefined) { robin = this._robins[source] = 0; }\n    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;\n  \n    switch(typeof(data)) {\n      \n    case \"number\":\n      if (estimatedEntropy === undefined) {\n        estimatedEntropy = 1;\n      }\n      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);\n      break;\n      \n    case \"object\":\n      objName = Object.prototype.toString.call(data);\n      if (objName === \"[object Uint32Array]\") {\n        tmp = [];\n        for (i = 0; i < data.length; i++) {\n          tmp.push(data[i]);\n        }\n        data = tmp;\n      } else {\n        if (objName !== \"[object Array]\") {\n          err = 1;\n        }\n        for (i=0; i<data.length && !err; i++) {\n          if (typeof(data[i]) !== \"number\") {\n            err = 1;\n          }\n        }\n      }\n      if (!err) {\n        if (estimatedEntropy === undefined) {\n          /* horrible entropy estimator */\n          estimatedEntropy = 0;\n          for (i=0; i<data.length; i++) {\n            tmp= data[i];\n            while (tmp>0) {\n              estimatedEntropy++;\n              tmp = tmp >>> 1;\n            }\n          }\n        }\n        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));\n      }\n      break;\n      \n    case \"string\":\n      if (estimatedEntropy === undefined) {\n       /* English text has just over 1 bit per character of entropy.\n        * But this might be HTML or something, and have far less\n        * entropy than English...  Oh well, let's just say one bit.\n        */\n       estimatedEntropy = data.length;\n      }\n      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);\n      this._pools[robin].update(data);\n      break;\n      \n    default:\n      err=1;\n    }\n    if (err) {\n      throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    }\n  \n    /* record the new strength */\n    this._poolEntropy[robin] += estimatedEntropy;\n    this._poolStrength += estimatedEntropy;\n  \n    /* fire off events */\n    if (oldReady === this._NOT_READY) {\n      if (this.isReady() !== this._NOT_READY) {\n        this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n      }\n      this._fireEvent(\"progress\", this.getProgress());\n    }\n  },\n  \n  /** Is the generator ready? */\n  isReady: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength && this._strength >= entropyRequired) {\n      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?\n        this._REQUIRES_RESEED | this._READY :\n        this._READY;\n    } else {\n      return (this._poolStrength >= entropyRequired) ?\n        this._REQUIRES_RESEED | this._NOT_READY :\n        this._NOT_READY;\n    }\n  },\n  \n  /** Get the generator's progress toward readiness, as a fraction */\n  getProgress: function (paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];\n  \n    if (this._strength >= entropyRequired) {\n      return 1.0;\n    } else {\n      return (this._poolStrength > entropyRequired) ?\n        1.0 :\n        this._poolStrength / entropyRequired;\n    }\n  },\n  \n  /** start the built-in entropy collectors */\n  startCollectors: function () {\n    if (this._collectorsStarted) { return; }\n  \n    this._eventListener = {\n      loadTimeCollector: this._bind(this._loadTimeCollector),\n      mouseCollector: this._bind(this._mouseCollector),\n      keyboardCollector: this._bind(this._keyboardCollector),\n      accelerometerCollector: this._bind(this._accelerometerCollector)\n    }\n\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.addEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.addEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.addEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n    } else if (document.attachEvent) {\n      document.attachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.attachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.attachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    } else {\n      throw new sjcl.exception.bug(\"can't attach event\");\n    }\n  \n    this._collectorsStarted = true;\n  },\n  \n  /** stop the built-in entropy collectors */\n  stopCollectors: function () {\n    if (!this._collectorsStarted) { return; }\n  \n    if (window.removeEventListener) {\n      window.removeEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n      window.removeEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n      window.removeEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n      window.removeEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n    } else if (document.detachEvent) {\n      document.detachEvent(\"onload\", this._eventListener.loadTimeCollector);\n      document.detachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n      document.detachEvent(\"keypress\", this._eventListener.keyboardCollector);\n    }\n\n    this._collectorsStarted = false;\n  },\n  \n  /* use a cookie to store entropy.\n  useCookie: function (all_cookies) {\n      throw new sjcl.exception.bug(\"random: useCookie is unimplemented\");\n  },*/\n  \n  /** add an event listener for progress or seeded-ness. */\n  addEventListener: function (name, callback) {\n    this._callbacks[name][this._callbackI++] = callback;\n  },\n  \n  /** remove an event listener for progress or seeded-ness */\n  removeEventListener: function (name, cb) {\n    var i, j, cbs=this._callbacks[name], jsTemp=[];\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n        jsTemp.push(j);\n      }\n    }\n\n    for (i=0; i<jsTemp.length; i++) {\n      j = jsTemp[i];\n      delete cbs[j];\n    }\n  },\n  \n  _bind: function (func) {\n    var that = this;\n    return function () {\n      func.apply(that, arguments);\n    };\n  },\n\n  /** Generate 4 random words, no reseed, no gate.\n   * @private\n   */\n  _gen4words: function () {\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n    return this._cipher.encrypt(this._counter);\n  },\n  \n  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.\n   * @private\n   */\n  _gate: function () {\n    this._key = this._gen4words().concat(this._gen4words());\n    this._cipher = new sjcl.cipher.aes(this._key);\n  },\n  \n  /** Reseed the generator with the given words\n   * @private\n   */\n  _reseed: function (seedWords) {\n    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n    this._cipher = new sjcl.cipher.aes(this._key);\n    for (var i=0; i<4; i++) {\n      this._counter[i] = this._counter[i]+1 | 0;\n      if (this._counter[i]) { break; }\n    }\n  },\n  \n  /** reseed the data from the entropy pools\n   * @param full If set, use all the entropy pools in the reseed.\n   */\n  _reseedFromPools: function (full) {\n    var reseedData = [], strength = 0, i;\n  \n    this._nextReseed = reseedData[0] =\n      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;\n    \n    for (i=0; i<16; i++) {\n      /* On some browsers, this is cryptographically random.  So we might\n       * as well toss it in the pot and stir...\n       */\n      reseedData.push(Math.random()*0x100000000|0);\n    }\n    \n    for (i=0; i<this._pools.length; i++) {\n     reseedData = reseedData.concat(this._pools[i].finalize());\n     strength += this._poolEntropy[i];\n     this._poolEntropy[i] = 0;\n   \n     if (!full && (this._reseedCount & (1<<i))) { break; }\n    }\n  \n    /* if we used the last pool, push a new one onto the stack */\n    if (this._reseedCount >= 1 << this._pools.length) {\n     this._pools.push(new sjcl.hash.sha256());\n     this._poolEntropy.push(0);\n    }\n  \n    /* how strong was this reseed? */\n    this._poolStrength -= strength;\n    if (strength > this._strength) {\n      this._strength = strength;\n    }\n  \n    this._reseedCount ++;\n    this._reseed(reseedData);\n  },\n  \n  _keyboardCollector: function () {\n    this._addCurrentTimeToEntropy(1);\n  },\n  \n  _mouseCollector: function (ev) {\n    var x = ev.x || ev.clientX || ev.offsetX || 0, y = ev.y || ev.clientY || ev.offsetY || 0;\n    sjcl.random.addEntropy([x,y], 2, \"mouse\");\n    this._addCurrentTimeToEntropy(0);\n  },\n  \n  _loadTimeCollector: function () {\n    this._addCurrentTimeToEntropy(2);\n  },\n\n  _addCurrentTimeToEntropy: function (estimatedEntropy) {\n    if (window && window.performance && typeof window.performance.now === \"function\") {\n      //how much entropy do we want to add here?\n      sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, \"loadtime\");\n    } else {\n      sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, \"loadtime\");\n    }\n  },\n  _accelerometerCollector: function (ev) {\n    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;\n    if(window.orientation){\n      var or = window.orientation;\n      if (typeof or === \"number\") {\n        sjcl.random.addEntropy(or, 1, \"accelerometer\");\n      }\n    }\n    if (ac) {\n      sjcl.random.addEntropy(ac, 2, \"accelerometer\");\n    }\n    this._addCurrentTimeToEntropy(0);\n  },\n\n  _fireEvent: function (name, arg) {\n    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];\n    /* TODO: there is a race condition between removing collectors and firing them */\n\n    /* I'm not sure if this is necessary; in C++, iterating over a\n     * collection and modifying it at the same time is a no-no.\n     */\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j)) {\n        cbsTemp.push(cbs[j]);\n      }\n    }\n\n    for (j=0; j<cbsTemp.length; j++) {\n      cbsTemp[j](arg);\n    }\n  }\n};\n\n/** an instance for the prng.\n* @see sjcl.prng\n*/\nsjcl.random = new sjcl.prng(6);\n\n(function(){\n  // function for getting nodejs crypto module. catches and ignores errors.\n  function getCryptoModule() {\n    try {\n      return require('__SYSTEM__/crypto');\n    }\n    catch (e) {\n      return null;\n    }\n  }\n\n  try {\n    var buf, crypt, ab;\n\n    // get cryptographically strong entropy depending on runtime environment\n    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {\n      buf = crypt.randomBytes(1024/8);\n      buf = new Uint32Array(new Uint8Array(buf).buffer);\n      sjcl.random.addEntropy(buf, 1024, \"crypto.randomBytes\");\n\n    } else if (window && Uint32Array) {\n      ab = new Uint32Array(32);\n      if (window.crypto && window.crypto.getRandomValues) {\n        window.crypto.getRandomValues(ab);\n      } else if (window.msCrypto && window.msCrypto.getRandomValues) {\n        window.msCrypto.getRandomValues(ab);\n      } else {\n        return;\n      }\n\n      // get cryptographically strong entropy in Webkit\n      sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n\n    } else {\n      // no getRandomValues :-(\n    }\n  } catch (e) {\n    if (typeof window !== 'undefined' && window.console) {\n      console.log(\"There was an error collecting entropy from the browser:\");\n      console.log(e);\n      //we do not want the library to fail due to randomness not being maintained.\n    }\n  }\n}());\n/** @fileOverview Convenince functions centered around JSON encapsulation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n \n /** @namespace JSON encapsulation */\n sjcl.json = {\n  /** Default values for encryption */\n  defaults: { v:1, iter:1000, ks:128, ts:64, mode:\"ccm\", adata:\"\", cipher:\"aes\" },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {Object} The cipher raw data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  _encrypt: function (password, plaintext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },\n                                  j.defaults), tmp, prp, adata;\n    j._add(p, params);\n    adata = p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {\n      tmp = password.kem();\n      p.kemtag = tmp.tag;\n      password = tmp.key.slice(0,p.ks/32);\n    }\n    if (typeof plaintext === \"string\") {\n      plaintext = sjcl.codec.utf8String.toBits(plaintext);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    /* do the encryption */\n    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n\n    //return j.encode(j._subtract(p, j.defaults));\n    return p;\n  },\n\n  /** Simple encryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} plaintext The data to encrypt.\n   * @param {Object} [params] The parameters including tag, iv and salt.\n   * @param {Object} [rp] A returned version with filled-in parameters.\n   * @return {String} The ciphertext serialized data.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   */\n  encrypt: function (password, plaintext, params, rp) {\n    var j = sjcl.json, p = j._encrypt.apply(j, arguments);\n    return j.encode(p);\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {Object} ciphertext The cipher raw data to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  _decrypt: function (password, ciphertext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] ||\n        !sjcl.cipher[p.cipher] ||\n        (typeof password === \"string\" && p.iter <= 100) ||\n        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n        (!p.iv) ||\n        (p.iv.length < 2 || p.iv.length > 4)) {\n      throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0,p.ks/32);\n      p.salt  = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {\n      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);\n    }\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n    prp = new sjcl.cipher[p.cipher](password);\n\n    /* do the decryption */\n    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n\n    /* return the json data */\n    j._add(rp, p);\n    rp.key = password;\n\n    return sjcl.codec.utf8String.fromBits(ct);\n  },\n\n  /** Simple decryption function.\n   * @param {String|bitArray} password The password or key.\n   * @param {String} ciphertext The ciphertext to decrypt.\n   * @param {Object} [params] Additional non-default parameters.\n   * @param {Object} [rp] A returned object with filled parameters.\n   * @return {String} The plaintext.\n   * @throws {sjcl.exception.invalid} if a parameter is invalid.\n   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n   */\n  decrypt: function (password, ciphertext, params, rp) {\n    var j = sjcl.json;\n    return j._decrypt(password, j.decode(ciphertext), params, rp);\n  },\n  \n  /** Encode a flat structure into a JSON string.\n   * @param {Object} obj The structure to encode.\n   * @return {String} A JSON string.\n   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.\n   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.\n   */\n  encode: function (obj) {\n    var i, out='{', comma='';\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (!i.match(/^[a-z0-9]+$/i)) {\n          throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        }\n        out += comma + '\"' + i + '\":';\n        comma = ',';\n\n        switch (typeof obj[i]) {\n          case 'number':\n          case 'boolean':\n            out += obj[i];\n            break;\n\n          case 'string':\n            out += '\"' + escape(obj[i]) + '\"';\n            break;\n\n          case 'object':\n            out += '\"' + sjcl.codec.base64.fromBits(obj[i],0) + '\"';\n            break;\n\n          default:\n            throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n    return out+'}';\n  },\n  \n  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,\n   * adata, salt and iv will be base64-decoded.\n   * @param {String} str The string.\n   * @return {Object} The decoded structure.\n   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.\n   */\n  decode: function (str) {\n    str = str.replace(/\\s/g,'');\n    if (!str.match(/^\\{.*\\}$/)) { \n      throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    }\n    var a = str.replace(/^\\{|\\}$/g, '').split(/,/), out={}, i, m;\n    for (i=0; i<a.length; i++) {\n      if (!(m=a[i].match(/^(?:([\"']?)([a-z][a-z0-9]*)\\1):(?:(\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\")$/i))) {\n        throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      }\n      if (m[3]) {\n        out[m[2]] = parseInt(m[3],10);\n      } else {\n        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n      }\n    }\n    return out;\n  },\n  \n  /** Insert all elements of src into target, modifying and returning target.\n   * @param {Object} target The object to be modified.\n   * @param {Object} src The object to pull data from.\n   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.\n   * @return {Object} target.\n   * @private\n   */\n  _add: function (target, src, requireSame) {\n    if (target === undefined) { target = {}; }\n    if (src === undefined) { return target; }\n    var i;\n    for (i in src) {\n      if (src.hasOwnProperty(i)) {\n        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n          throw new sjcl.exception.invalid(\"required parameter overridden\");\n        }\n        target[i] = src[i];\n      }\n    }\n    return target;\n  },\n  \n  /** Remove all elements of minus from plus.  Does not modify plus.\n   * @private\n   */\n  _subtract: function (plus, minus) {\n    var out = {}, i;\n\n    for (i in plus) {\n      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n        out[i] = plus[i];\n      }\n    }\n\n    return out;\n  },\n  \n  /** Return only the specified elements of src.\n   * @private\n   */\n  _filter: function (src, filter) {\n    var out = {}, i;\n    for (i=0; i<filter.length; i++) {\n      if (src[filter[i]] !== undefined) {\n        out[filter[i]] = src[filter[i]];\n      }\n    }\n    return out;\n  }\n};\n\n/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} plaintext The data to encrypt.\n * @param {Object} [params] The parameters including tag, iv and salt.\n * @param {Object} [rp] A returned version with filled-in parameters.\n * @return {String} The ciphertext.\n */\nsjcl.encrypt = sjcl.json.encrypt;\n\n/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} ciphertext The ciphertext to decrypt.\n * @param {Object} [params] Additional non-default parameters.\n * @param {Object} [rp] A returned object with filled parameters.\n * @return {String} The plaintext.\n */\nsjcl.decrypt = sjcl.json.decrypt;\n\n/** The cache for cachedPbkdf2.\n * @private\n */\nsjcl.misc._pbkdf2Cache = {};\n\n/** Cached PBKDF2 key derivation.\n * @param {String} password The password.\n * @param {Object} [obj] The derivation params (iteration count and optional salt).\n * @return {Object} The derived data in key, the salt in salt.\n */\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;\n  \n  obj = obj || {};\n  iter = obj.iter || 1000;\n  \n  /* open the cache for this password and iteration count */\n  cp = cache[password] = cache[password] || {};\n  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?\n                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };\n          \n  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;\n  \n  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n  return { key: c[salt].slice(0), salt:salt.slice(0) };\n};\n\n\n/**\n * @constructor\n * Constructs a new bignum from another bignum, a number or a hex string.\n */\nsjcl.bn = function(it) {\n  this.initWith(it);\n};\n\nsjcl.bn.prototype = {\n  radix: 24,\n  maxMul: 8,\n  _class: sjcl.bn,\n  \n  copy: function() {\n    return new this._class(this);\n  },\n\n  /**\n   * Initializes this with it, either as a bn, a number, or a hex string.\n   */\n  initWith: function(it) {\n    var i=0, k;\n    switch(typeof it) {\n    case \"object\":\n      this.limbs = it.limbs.slice(0);\n      break;\n      \n    case \"number\":\n      this.limbs = [it];\n      this.normalize();\n      break;\n      \n    case \"string\":\n      it = it.replace(/^0x/, '');\n      this.limbs = [];\n      // hack\n      k = this.radix / 4;\n      for (i=0; i < it.length; i+=k) {\n        this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i),16));\n      }\n      break;\n\n    default:\n      this.limbs = [0];\n    }\n    return this;\n  },\n\n  /**\n   * Returns true if \"this\" and \"that\" are equal.  Calls fullReduce().\n   * Equality test is in constant time.\n   */\n  equals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var difference = 0, i;\n    this.fullReduce();\n    that.fullReduce();\n    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {\n      difference |= this.getLimb(i) ^ that.getLimb(i);\n    }\n    return (difference === 0);\n  },\n  \n  /**\n   * Get the i'th limb of this, zero if i is too large.\n   */\n  getLimb: function(i) {\n    return (i >= this.limbs.length) ? 0 : this.limbs[i];\n  },\n  \n  /**\n   * Constant time comparison function.\n   * Returns 1 if this >= that, or zero otherwise.\n   */\n  greaterEquals: function(that) {\n    if (typeof that === \"number\") { that = new this._class(that); }\n    var less = 0, greater = 0, i, a, b;\n    i = Math.max(this.limbs.length, that.limbs.length) - 1;\n    for (; i>= 0; i--) {\n      a = this.getLimb(i);\n      b = that.getLimb(i);\n      greater |= (b - a) & ~less;\n      less |= (a - b) & ~greater;\n    }\n    return (greater | ~less) >>> 31;\n  },\n  \n  /**\n   * Convert to a hex string.\n   */\n  toString: function() {\n    this.fullReduce();\n    var out=\"\", i, s, l = this.limbs;\n    for (i=0; i < this.limbs.length; i++) {\n      s = l[i].toString(16);\n      while (i < this.limbs.length - 1 && s.length < 6) {\n        s = \"0\" + s;\n      }\n      out = s + out;\n    }\n    return \"0x\"+out;\n  },\n  \n  /** this += that.  Does not normalize. */\n  addM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] += ll[i];\n    }\n    return this;\n  },\n  \n  /** this *= 2.  Requires normalized; ends up normalized. */\n  doubleM: function() {\n    var i, carry=0, tmp, r=this.radix, m=this.radixMask, l=this.limbs;\n    for (i=0; i<l.length; i++) {\n      tmp = l[i];\n      tmp = tmp+tmp+carry;\n      l[i] = tmp & m;\n      carry = tmp >> r;\n    }\n    if (carry) {\n      l.push(carry);\n    }\n    return this;\n  },\n  \n  /** this /= 2, rounded down.  Requires normalized; ends up normalized. */\n  halveM: function() {\n    var i, carry=0, tmp, r=this.radix, l=this.limbs;\n    for (i=l.length-1; i>=0; i--) {\n      tmp = l[i];\n      l[i] = (tmp+carry)>>1;\n      carry = (tmp&1) << r;\n    }\n    if (!l[l.length-1]) {\n      l.pop();\n    }\n    return this;\n  },\n\n  /** this -= that.  Does not normalize. */\n  subM: function(that) {\n    if (typeof(that) !== \"object\") { that = new this._class(that); }\n    var i, l=this.limbs, ll=that.limbs;\n    for (i=l.length; i<ll.length; i++) {\n      l[i] = 0;\n    }\n    for (i=0; i<ll.length; i++) {\n      l[i] -= ll[i];\n    }\n    return this;\n  },\n  \n  mod: function(that) {\n    var neg = !this.greaterEquals(new sjcl.bn(0));\n    \n    that = new sjcl.bn(that).normalize(); // copy before we begin\n    var out = new sjcl.bn(this).normalize(), ci=0;\n    \n    if (neg) out = (new sjcl.bn(0)).subM(out).normalize();\n    \n    for (; out.greaterEquals(that); ci++) {\n      that.doubleM();\n    }\n    \n    if (neg) out = that.sub(out).normalize();\n    \n    for (; ci > 0; ci--) {\n      that.halveM();\n      if (out.greaterEquals(that)) {\n        out.subM(that).normalize();\n      }\n    }\n    return out.trim();\n  },\n  \n  /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */\n  inverseMod: function(p) {\n    var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz=1;\n    \n    if (!(p.limbs[0] & 1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p must be odd\"));\n    }\n    \n    // invariant: y is odd\n    do {\n      if (x.limbs[0] & 1) {\n        if (!x.greaterEquals(y)) {\n          // x < y; swap everything\n          tmp = x; x = y; y = tmp;\n          tmp = a; a = b; b = tmp;\n        }\n        x.subM(y);\n        x.normalize();\n        \n        if (!a.greaterEquals(b)) {\n          a.addM(p);\n        }\n        a.subM(b);\n      }\n      \n      // cut everything in half\n      x.halveM();\n      if (a.limbs[0] & 1) {\n        a.addM(p);\n      }\n      a.normalize();\n      a.halveM();\n      \n      // check for termination: x ?= 0\n      for (i=nz=0; i<x.limbs.length; i++) {\n        nz |= x.limbs[i];\n      }\n    } while(nz);\n    \n    if (!y.equals(1)) {\n      throw (new sjcl.exception.invalid(\"inverseMod: p and x must be relatively prime\"));\n    }\n    \n    return b;\n  },\n  \n  /** this + that.  Does not normalize. */\n  add: function(that) {\n    return this.copy().addM(that);\n  },\n\n  /** this - that.  Does not normalize. */\n  sub: function(that) {\n    return this.copy().subM(that);\n  },\n  \n  /** this * that.  Normalizes and reduces. */\n  mul: function(that) {\n    if (typeof(that) === \"number\") { that = new this._class(that); }\n    var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii=this.maxMul;\n\n    for (i=0; i < this.limbs.length + that.limbs.length + 1; i++) {\n      c[i] = 0;\n    }\n    for (i=0; i<al; i++) {\n      ai = a[i];\n      for (j=0; j<bl; j++) {\n        c[i+j] += ai * b[j];\n      }\n     \n      if (!--ii) {\n        ii = this.maxMul;\n        out.cnormalize();\n      }\n    }\n    return out.cnormalize().reduce();\n  },\n\n  /** this ^ 2.  Normalizes and reduces. */\n  square: function() {\n    return this.mul(this);\n  },\n\n  /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */\n  power: function(l) {\n    if (typeof(l) === \"number\") {\n      l = [l];\n    } else if (l.limbs !== undefined) {\n      l = l.normalize().limbs;\n    }\n    var i, j, out = new this._class(1), pow = this;\n\n    for (i=0; i<l.length; i++) {\n      for (j=0; j<this.radix; j++) {\n        if (l[i] & (1<<j)) {\n          out = out.mul(pow);\n        }\n        pow = pow.square();\n      }\n    }\n    \n    return out;\n  },\n\n  /** this * that mod N */\n  mulmod: function(that, N) {\n    return this.mod(N).mul(that.mod(N)).mod(N);\n  },\n\n  /** this ^ x mod N */\n  powermod: function(x, N) {\n    var result = new sjcl.bn(1), a = new sjcl.bn(this), k = new sjcl.bn(x);\n    while (true) {\n      if (k.limbs[0] & 1) { result = result.mulmod(a, N); }\n      k.halveM();\n      if (k.equals(0)) { break; }\n      a = a.mulmod(a, N);\n    }\n    return result.normalize().reduce();\n  },\n\n  trim: function() {\n    var l = this.limbs, p;\n    do {\n      p = l.pop();\n    } while (l.length && p === 0);\n    l.push(p);\n    return this;\n  },\n  \n  /** Reduce mod a modulus.  Stubbed for subclassing. */\n  reduce: function() {\n    return this;\n  },\n\n  /** Reduce and normalize. */\n  fullReduce: function() {\n    return this.normalize();\n  },\n  \n  /** Propagate carries. */\n  normalize: function() {\n    var carry=0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll || (carry !== 0 && carry !== -1); i++) {\n      l = (limbs[i]||0) + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    if (carry === -1) {\n      limbs[i-1] -= pv;\n    }\n    return this;\n  },\n\n  /** Constant-time normalize. Does not allocate additional space. */\n  cnormalize: function() {\n    var carry=0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n    for (i=0; i < ll-1; i++) {\n      l = limbs[i] + carry;\n      m = limbs[i] = l & mask;\n      carry = (l-m)*ipv;\n    }\n    limbs[i] += carry;\n    return this;\n  },\n  \n  /** Serialize to a bit array */\n  toBits: function(len) {\n    this.fullReduce();\n    len = len || this.exponent || this.bitLength();\n    var i = Math.floor((len-1)/24), w=sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix,\n        out = [w.partial(e, this.getLimb(i))];\n    for (i--; i >= 0; i--) {\n      out = w.concat(out, [w.partial(Math.min(this.radix,len), this.getLimb(i))]);\n      len -= this.radix;\n    }\n    return out;\n  },\n  \n  /** Return the length in bits, rounded up to the nearest byte. */\n  bitLength: function() {\n    this.fullReduce();\n    var out = this.radix * (this.limbs.length - 1),\n        b = this.limbs[this.limbs.length - 1];\n    for (; b; b >>>= 1) {\n      out ++;\n    }\n    return out+7 & -8;\n  }\n};\n\n/** @memberOf sjcl.bn\n* @this { sjcl.bn }\n*/\nsjcl.bn.fromBits = function(bits) {\n  var Class = this, out = new Class(), words=[], w=sjcl.bitArray, t = this.prototype,\n      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;\n  \n  words[0] = w.extract(bits, 0, e);\n  for (; e < l; e += t.radix) {\n    words.unshift(w.extract(bits, e, t.radix));\n  }\n\n  out.limbs = words;\n  return out;\n};\n\n\n\nsjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2,sjcl.bn.prototype.radix));\nsjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;\n\n/**\n * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,\n * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.\n */\nsjcl.bn.pseudoMersennePrime = function(exponent, coeff) {\n  /** @constructor \n  * @private\n  */\n  function p(it) {\n    this.initWith(it);\n    /*if (this.limbs[this.modOffset]) {\n      this.reduce();\n    }*/\n  }\n\n  var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;\n  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);\n  ppr.exponent = exponent;\n  ppr.offset = [];\n  ppr.factor = [];\n  ppr.minOffset = mo;\n  ppr.fullMask = 0;\n  ppr.fullOffset = [];\n  ppr.fullFactor = [];\n  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2,exponent));\n  \n  ppr.fullMask = 0|-Math.pow(2, exponent % ppr.radix);\n\n  for (i=0; i<coeff.length; i++) {\n    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);\n    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);\n    ppr.factor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);\n    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1/2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);\n    ppr.modulus.addM(new sjcl.bn(Math.pow(2,coeff[i][0])*coeff[i][1]));\n    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative\n  }\n  ppr._class = p;\n  ppr.modulus.cnormalize();\n\n  /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p.\n   * @memberof sjcl.bn\n   * @this { sjcl.bn }\n   */\n  ppr.reduce = function() {\n    var i, k, l, mo = this.modOffset, limbs = this.limbs, off = this.offset, ol = this.offset.length, fac = this.factor, ll;\n\n    i = this.minOffset;\n    while (limbs.length > mo) {\n      l = limbs.pop();\n      ll = limbs.length;\n      for (k=0; k<ol; k++) {\n        limbs[ll+off[k]] -= fac[k] * l;\n      }\n      \n      i--;\n      if (!i) {\n        limbs.push(0);\n        this.cnormalize();\n        i = this.minOffset;\n      }\n    }\n    this.cnormalize();\n\n    return this;\n  };\n  \n  /** @memberof sjcl.bn\n  * @this { sjcl.bn }\n  */\n  ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function() {\n    var limbs = this.limbs, i = limbs.length - 1, k, l;\n    this.reduce();\n    if (i === this.modOffset - 1) {\n      l = limbs[i] & this.fullMask;\n      limbs[i] -= l;\n      for (k=0; k<this.fullOffset.length; k++) {\n        limbs[i+this.fullOffset[k]] -= this.fullFactor[k] * l;\n      }\n      this.normalize();\n    }\n  };\n\n  /** mostly constant-time, very expensive full reduction.\n   * @memberof sjcl.bn\n   * @this { sjcl.bn }\n   */\n  ppr.fullReduce = function() {\n    var greater, i;\n    // massively above the modulus, may be negative\n    \n    this._strongReduce();\n    // less than twice the modulus, may be negative\n\n    this.addM(this.modulus);\n    this.addM(this.modulus);\n    this.normalize();\n    // probably 2-3x the modulus\n    \n    this._strongReduce();\n    // less than the power of 2.  still may be more than\n    // the modulus\n\n    // HACK: pad out to this length\n    for (i=this.limbs.length; i<this.modOffset; i++) {\n      this.limbs[i] = 0;\n    }\n    \n    // constant-time subtract modulus\n    greater = this.greaterEquals(this.modulus);\n    for (i=0; i<this.limbs.length; i++) {\n      this.limbs[i] -= this.modulus.limbs[i] * greater;\n    }\n    this.cnormalize();\n\n    return this;\n  };\n\n\n  /** @memberof sjcl.bn\n  * @this { sjcl.bn }\n  */\n  ppr.inverse = function() {\n    return (this.power(this.modulus.sub(2)));\n  };\n\n  p.fromBits = sjcl.bn.fromBits;\n\n  return p;\n};\n\n// a small Mersenne prime\nvar sbp = sjcl.bn.pseudoMersennePrime;\nsjcl.bn.prime = {\n  p127: sbp(127, [[0,-1]]),\n\n  // Bernstein's prime for Curve25519\n  p25519: sbp(255, [[0,-19]]),\n\n  // Koblitz primes\n  p192k: sbp(192, [[32,-1],[12,-1],[8,-1],[7,-1],[6,-1],[3,-1],[0,-1]]),\n  p224k: sbp(224, [[32,-1],[12,-1],[11,-1],[9,-1],[7,-1],[4,-1],[1,-1],[0,-1]]),\n  p256k: sbp(256, [[32,-1],[9,-1],[8,-1],[7,-1],[6,-1],[4,-1],[0,-1]]),\n\n  // NIST primes\n  p192: sbp(192, [[0,-1],[64,-1]]),\n  p224: sbp(224, [[0,1],[96,-1]]),\n  p256: sbp(256, [[0,-1],[96,1],[192,1],[224,-1]]),\n  p384: sbp(384, [[0,-1],[32,1],[96,-1],[128,-1]]),\n  p521: sbp(521, [[0,-1]])\n};\n\nsjcl.bn.random = function(modulus, paranoia) {\n  if (typeof modulus !== \"object\") { modulus = new sjcl.bn(modulus); }\n  var words, i, l = modulus.limbs.length, m = modulus.limbs[l-1]+1, out = new sjcl.bn();\n  while (true) {\n    // get a sequence whose first digits make sense\n    do {\n      words = sjcl.random.randomWords(l, paranoia);\n      if (words[l-1] < 0) { words[l-1] += 0x100000000; }\n    } while (Math.floor(words[l-1] / m) === Math.floor(0x100000000 / m));\n    words[l-1] %= m;\n\n    // mask off all the limbs\n    for (i=0; i<l-1; i++) {\n      words[i] &= modulus.radixMask;\n    }\n\n    // check the rest of the digitssj\n    out.limbs = words;\n    if (!out.greaterEquals(modulus)) {\n      return out;\n    }\n  }\n};\n\n/**\n * base class for all ecc operations.\n */\nsjcl.ecc = {};\n\n/**\n * Represents a point on a curve in affine coordinates.\n * @constructor\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n * @param {bigInt} x The x coordinate.\n * @param {bigInt} y The y coordinate.\n */\nsjcl.ecc.point = function(curve,x,y) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\n\n\nsjcl.ecc.point.prototype = {\n  toJac: function() {\n    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));\n  },\n\n  mult: function(k) {\n    return this.toJac().mult(k, this).toAffine();\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k, k2, affine2) {\n    return this.toJac().mult2(k, this, k2, affine2).toAffine();\n  },\n  \n  multiples: function() {\n    var m, i, j;\n    if (this._multiples === undefined) {\n      j = this.toJac().doubl();\n      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];\n      for (i=3; i<16; i++) {\n        j = j.add(this);\n        m.push(j.toAffine());\n      }\n    }\n    return this._multiples;\n  },\n\n  isValid: function() {\n    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));\n  },\n\n  toBits: function() {\n    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());\n  }\n};\n\n/**\n * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which\n * will be converted to bigInts).\n *\n * @constructor\n * @param {bigInt/string} x The x coordinate.\n * @param {bigInt/string} y The y coordinate.\n * @param {bigInt/string} z The z coordinate.\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n */\nsjcl.ecc.pointJac = function(curve, x, y, z) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isIdentity = false;\n  }\n  this.curve = curve;\n};\n\nsjcl.ecc.pointJac.prototype = {\n  /**\n   * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.\n   * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.\n   * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates. \n   */\n  add: function(T) {\n    var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;\n    if (S.curve !== T.curve) {\n      throw(\"sjcl.ecc.add(): Points must be on the same curve to add them!\");\n    }\n\n    if (S.isIdentity) {\n      return T.toJac();\n    } else if (T.isIdentity) {\n      return S;\n    }\n\n    sz2 = S.z.square();\n    c = T.x.mul(sz2).subM(S.x);\n\n    if (c.equals(0)) {\n      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {\n        // same point\n        return S.doubl();\n      } else {\n        // inverses\n        return new sjcl.ecc.pointJac(S.curve);\n      }\n    }\n    \n    d = T.y.mul(sz2.mul(S.z)).subM(S.y);\n    c2 = c.square();\n\n    x1 = d.square();\n    x2 = c.square().mul(c).addM( S.x.add(S.x).mul(c2) );\n    x  = x1.subM(x2);\n\n    y1 = S.x.mul(c2).subM(x).mul(d);\n    y2 = S.y.mul(c.square().mul(c));\n    y  = y1.subM(y2);\n\n    z  = S.z.mul(c);\n\n    return new sjcl.ecc.pointJac(this.curve,x,y,z);\n  },\n  \n  /**\n   * doubles this point.\n   * @return {sjcl.ecc.pointJac} The doubled point.\n   */\n  doubl: function() {\n    if (this.isIdentity) { return this; }\n\n    var\n      y2 = this.y.square(),\n      a  = y2.mul(this.x.mul(4)),\n      b  = y2.square().mul(8),\n      z2 = this.z.square(),\n      c  = this.curve.a.toString() == (new sjcl.bn(-3)).toString() ?\n                this.x.sub(z2).mul(3).mul(this.x.add(z2)) :\n                this.x.square().mul(3).add(z2.square().mul(this.curve.a)),\n      x  = c.square().subM(a).subM(a),\n      y  = a.sub(x).mul(c).subM(b),\n      z  = this.y.add(this.y).mul(this.z);\n    return new sjcl.ecc.pointJac(this.curve, x, y, z);\n  },\n\n  /**\n   * Returns a copy of this point converted to affine coordinates.\n   * @return {sjcl.ecc.point} The converted point.\n   */\n  toAffine: function() {\n    if (this.isIdentity || this.z.equals(0)) {\n      return new sjcl.ecc.point(this.curve);\n    }\n    var zi = this.z.inverse(), zi2 = zi.square();\n    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());\n  },\n  \n  /**\n   * Multiply this point by k and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.\n   */\n  mult: function(k, affine) {\n    if (typeof(k) === \"number\") {\n      k = [k];\n    } else if (k.limbs !== undefined) {\n      k = k.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();\n\n    for (i=k.length-1; i>=0; i--) {\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(multiples[k[i]>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n  \n  /**\n   * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n   * @param {bigInt} k The coefficient to multiply this by.\n   * @param {sjcl.ecc.point} affine This point in affine coordinates.\n   * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n   * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n   * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n   */\n  mult2: function(k1, affine, k2, affine2) {\n    if (typeof(k1) === \"number\") {\n      k1 = [k1];\n    } else if (k1.limbs !== undefined) {\n      k1 = k1.normalize().limbs;\n    }\n    \n    if (typeof(k2) === \"number\") {\n      k2 = [k2];\n    } else if (k2.limbs !== undefined) {\n      k2 = k2.normalize().limbs;\n    }\n    \n    var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(),\n        m2 = affine2.multiples(), l1, l2;\n\n    for (i=Math.max(k1.length,k2.length)-1; i>=0; i--) {\n      l1 = k1[i] | 0;\n      l2 = k2[i] | 0;\n      for (j=sjcl.bn.prototype.radix-4; j>=0; j-=4) {\n        out = out.doubl().doubl().doubl().doubl().add(m1[l1>>j & 0xF]).add(m2[l2>>j & 0xF]);\n      }\n    }\n    \n    return out;\n  },\n\n  isValid: function() {\n    var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);\n    return this.y.square().equals(\n             this.curve.b.mul(z6).add(this.x.mul(\n               this.curve.a.mul(z4).add(this.x.square()))));\n  }\n};\n\n/**\n * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.\n *\n * @constructor\n * @param {bigInt} p The prime modulus.\n * @param {bigInt} r The prime order of the curve.\n * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).\n * @param {bigInt} x The x coordinate of a base point of the curve.\n * @param {bigInt} y The y coordinate of a base point of the curve.\n */\nsjcl.ecc.curve = function(Field, r, a, b, x, y) {\n  this.field = Field;\n  this.r = new sjcl.bn(r);\n  this.a = new Field(a);\n  this.b = new Field(b);\n  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));\n};\n\nsjcl.ecc.curve.prototype.fromBits = function (bits) {\n  var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8,\n      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)),\n                             this.field.fromBits(w.bitSlice(bits, l, 2*l)));\n  if (!p.isValid()) {\n    throw new sjcl.exception.corrupt(\"not on the curve!\");\n  }\n  return p;\n};\n\nsjcl.ecc.curves = {\n  c192: new sjcl.ecc.curve(\n    sjcl.bn.prime.p192,\n    \"0xffffffffffffffffffffffff99def836146bc9b1b4d22831\",\n    -3,\n    \"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\",\n    \"0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\",\n    \"0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"),\n\n  c224: new sjcl.ecc.curve(\n    sjcl.bn.prime.p224,\n    \"0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d\",\n    -3,\n    \"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\",\n    \"0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\",\n    \"0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\"),\n\n  c256: new sjcl.ecc.curve(\n    sjcl.bn.prime.p256,\n    \"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\",\n    -3,\n    \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",\n    \"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",\n    \"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n\n  c384: new sjcl.ecc.curve(\n    sjcl.bn.prime.p384,\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\",\n    -3,\n    \"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\",\n    \"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\",\n    \"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\"),\n\n  k192: new sjcl.ecc.curve(\n    sjcl.bn.prime.p192k,\n    \"0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d\",\n    0,\n    3,\n    \"0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d\",\n    \"0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d\"),\n\n  k224: new sjcl.ecc.curve(\n    sjcl.bn.prime.p224k,\n    \"0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7\",\n    0,\n    5,\n    \"0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c\",\n    \"0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5\"),\n\n  k256: new sjcl.ecc.curve(\n    sjcl.bn.prime.p256k,\n    \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\n    0,\n    7,\n    \"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n    \"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n\n};\n\n/** our basicKey classes\n*/\nsjcl.ecc.basicKey = {\n  /** ecc publicKey. \n  * @constructor\n  * @param {curve} curve the elliptic curve\n  * @param {point} point the point on the curve\n  */\n  publicKey: function(curve, point) {\n    this._curve = curve;\n    this._curveBitLength = curve.r.bitLength();\n    if (point instanceof Array) {\n      this._point = curve.fromBits(point);\n    } else {\n      this._point = point;\n    }\n\n    /** get this keys point data\n    * @return x and y as bitArrays\n    */\n    this.get = function() {\n      var pointbits = this._point.toBits();\n      var len = sjcl.bitArray.bitLength(pointbits);\n      var x = sjcl.bitArray.bitSlice(pointbits, 0, len/2);\n      var y = sjcl.bitArray.bitSlice(pointbits, len/2);\n      return { x: x, y: y };\n    };\n  },\n\n  /** ecc secretKey\n  * @constructor\n  * @param {curve} curve the elliptic curve\n  * @param exponent\n  */\n  secretKey: function(curve, exponent) {\n    this._curve = curve;\n    this._curveBitLength = curve.r.bitLength();\n    this._exponent = exponent;\n\n    /** get this keys exponent data\n    * @return {bitArray} exponent\n    */\n    this.get = function () {\n      return this._exponent.toBits();\n    };\n  }\n};\n\n/** @private */\nsjcl.ecc.basicKey.generateKeys = function(cn) {\n  return function generateKeys(curve, paranoia, sec) {\n    curve = curve || 256;\n\n    if (typeof curve === \"number\") {\n      curve = sjcl.ecc.curves['c'+curve];\n      if (curve === undefined) {\n        throw new sjcl.exception.invalid(\"no such curve\");\n      }\n    }\n    sec = sec || sjcl.bn.random(curve.r, paranoia);\n\n    var pub = curve.G.mult(sec);\n    return { pub: new sjcl.ecc[cn].publicKey(curve, pub),\n             sec: new sjcl.ecc[cn].secretKey(curve, sec) };\n  };\n};\n\n/** elGamal keys */\nsjcl.ecc.elGamal = {\n  /** generate keys\n  * @function\n  * @param curve\n  * @param {int} paranoia Paranoia for generation (default 6)\n  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n  */\n  generateKeys: sjcl.ecc.basicKey.generateKeys(\"elGamal\"),\n  /** elGamal publicKey. \n  * @constructor\n  * @augments sjcl.ecc.basicKey.publicKey\n  */\n  publicKey: function (curve, point) {\n    sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n  },\n  /** elGamal secretKey\n  * @constructor\n  * @augments sjcl.ecc.basicKey.secretKey\n  */\n  secretKey: function (curve, exponent) {\n    sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n  }\n};\n\nsjcl.ecc.elGamal.publicKey.prototype = {\n  /** Kem function of elGamal Public Key\n  * @param paranoia paranoia to use for randomization.\n  * @return {object} key and tag. unkem(tag) with the corresponding secret key results in the key returned.\n  */\n  kem: function(paranoia) {\n    var sec = sjcl.bn.random(this._curve.r, paranoia),\n        tag = this._curve.G.mult(sec).toBits(),\n        key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());\n    return { key: key, tag: tag };\n  }\n};\n\nsjcl.ecc.elGamal.secretKey.prototype = {\n  /** UnKem function of elGamal Secret Key\n  * @param {bitArray} tag The Tag to decrypt.\n  * @return {bitArray} decrypted key.\n  */\n  unkem: function(tag) {\n    return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());\n  },\n\n  /** Diffie-Hellmann function\n  * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with\n  * @return {bitArray} diffie-hellmann result for this key combination.\n  */\n  dh: function(pk) {\n    return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());\n  }\n};\n\n/** ecdsa keys */\nsjcl.ecc.ecdsa = {\n  /** generate keys\n  * @function\n  * @param curve\n  * @param {int} paranoia Paranoia for generation (default 6)\n  * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n  */\n  generateKeys: sjcl.ecc.basicKey.generateKeys(\"ecdsa\")\n};\n\n/** ecdsa publicKey. \n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.publicKey = function (curve, point) {\n  sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n};\n\n/** specific functions for ecdsa publicKey. */\nsjcl.ecc.ecdsa.publicKey.prototype = {\n  /** Diffie-Hellmann function\n  * @param {bitArray} hash hash to verify. \n  * @param {bitArray} rs signature bitArray.\n  * @param {boolean}  fakeLegacyVersion use old legacy version\n  */\n  verify: function(hash, rs, fakeLegacyVersion) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n    var w = sjcl.bitArray,\n        R = this._curve.r,\n        l = this._curveBitLength,\n        r = sjcl.bn.fromBits(w.bitSlice(rs,0,l)),\n        ss = sjcl.bn.fromBits(w.bitSlice(rs,l,2*l)),\n        s = fakeLegacyVersion ? ss : ss.inverseMod(R),\n        hG = sjcl.bn.fromBits(hash).mul(s).mod(R),\n        hA = r.mul(s).mod(R),\n        r2 = this._curve.G.mult2(hG, hA, this._point).x;\n    if (r.equals(0) || ss.equals(0) || r.greaterEquals(R) || ss.greaterEquals(R) || !r2.equals(r)) {\n      if (fakeLegacyVersion === undefined) {\n        return this.verify(hash, rs, true);\n      } else {\n        throw (new sjcl.exception.corrupt(\"signature didn't check out\"));\n      }\n    }\n    return true;\n  }\n};\n\n/** ecdsa secretKey\n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.secretKey = function (curve, exponent) {\n  sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n};\n\n/** specific functions for ecdsa secretKey. */\nsjcl.ecc.ecdsa.secretKey.prototype = {\n  /** Diffie-Hellmann function\n  * @param {bitArray} hash hash to sign. \n  * @param {int} paranoia paranoia for random number generation\n  * @param {boolean} fakeLegacyVersion use old legacy version\n  */\n  sign: function(hash, paranoia, fakeLegacyVersion, fixedKForTesting) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n    var R  = this._curve.r,\n        l  = R.bitLength(),\n        k  = fixedKForTesting || sjcl.bn.random(R.sub(1), paranoia).add(1),\n        r  = this._curve.G.mult(k).x.mod(R),\n        ss = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)),\n        s  = fakeLegacyVersion ? ss.inverseMod(R).mul(k).mod(R)\n             : ss.mul(k.inverseMod(R)).mod(R);\n    return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n  }\n};\nreturn {\n    sjcl: (typeof sjcl !== \"undefined\") ? sjcl : null,\n    module: (typeof module !== \"undefined\") ? module : null,\n    Math: (typeof Math !== \"undefined\") ? Math : null,\n    String: (typeof String !== \"undefined\") ? String : null,\n    decodeURIComponent: (typeof decodeURIComponent !== \"undefined\") ? decodeURIComponent : null,\n    escape: (typeof escape !== \"undefined\") ? escape : null,\n    unescape: (typeof unescape !== \"undefined\") ? unescape : null,\n    encodeURIComponent: (typeof encodeURIComponent !== \"undefined\") ? encodeURIComponent : null,\n    parseInt: (typeof parseInt !== \"undefined\") ? parseInt : null,\n    Object: (typeof Object !== \"undefined\") ? Object : null,\n    window: (typeof window !== \"undefined\") ? window : null,\n    document: (typeof document !== \"undefined\") ? document : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    console: (typeof console !== \"undefined\") ? console : null,\n    sbp: (typeof sbp !== \"undefined\") ? sbp : null\n};\n}",
              "bottom": "return {\n    sjcl: (typeof sjcl !== \"undefined\") ? sjcl : null,\n    module: (typeof module !== \"undefined\") ? module : null,\n    Math: (typeof Math !== \"undefined\") ? Math : null,\n    String: (typeof String !== \"undefined\") ? String : null,\n    decodeURIComponent: (typeof decodeURIComponent !== \"undefined\") ? decodeURIComponent : null,\n    escape: (typeof escape !== \"undefined\") ? escape : null,\n    unescape: (typeof unescape !== \"undefined\") ? unescape : null,\n    encodeURIComponent: (typeof encodeURIComponent !== \"undefined\") ? encodeURIComponent : null,\n    parseInt: (typeof parseInt !== \"undefined\") ? parseInt : null,\n    Object: (typeof Object !== \"undefined\") ? Object : null,\n    window: (typeof window !== \"undefined\") ? window : null,\n    document: (typeof document !== \"undefined\") ? document : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    console: (typeof console !== \"undefined\") ? console : null,\n    sbp: (typeof sbp !== \"undefined\") ? sbp : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "crypto": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/crypto.js": {
            "requireId": "/__SYSTEM__/crypto",
            "memoizeId": "/__SYSTEM__/crypto.js",
            "descriptor": {
              "filename": "index.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/index.js",
              "mtime": 1383545607,
              "code": "var Buffer = require('buffer').Buffer\nvar sha = require('./sha')\nvar sha256 = require('./sha256')\nvar rng = require('./rng')\nvar md5 = require('./md5')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || 'sha1'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error('algorithm:', alg, 'is not yet supported')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach(['createCredentials'\n, 'createCipher'\n, 'createCipheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDiffieHellman'\n, 'pbkdf2'], function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n",
              "globals": {
                "Buffer": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "sha": {
                  "type": "assign"
                },
                "sha256": {
                  "type": "assign"
                },
                "rng": {
                  "type": "assign"
                },
                "md5": {
                  "type": "assign"
                },
                "algorithms": {
                  "type": "assign"
                },
                "blocksize": {
                  "type": "assign"
                },
                "zeroBuffer": {
                  "type": "assign"
                },
                "hmac": {
                  "type": "assign"
                },
                "hash": {
                  "type": "assign"
                },
                "error": {
                  "type": "call"
                },
                "exports": {
                  "type": "reference"
                },
                "each": {
                  "type": "assign"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "buffer": {
                    "where": "inline"
                  },
                  "./sha": {
                    "where": "inline"
                  },
                  "./sha256": {
                    "where": "inline"
                  },
                  "./rng": {
                    "where": "inline"
                  },
                  "./md5": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\nvar Buffer = require('__SYSTEM__/buffer').Buffer\nvar sha = require('./sha')\nvar sha256 = require('./sha256')\nvar rng = require('./rng')\nvar md5 = require('./md5')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || 'sha1'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error('algorithm:', alg, 'is not yet supported')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\neach(['createCredentials'\n, 'createCipher'\n, 'createCipheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDiffieHellman'\n, 'pbkdf2'], function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {
                "buffer": {
                  "where": "inline"
                },
                "./sha": {
                  "where": "inline"
                },
                "./sha256": {
                  "where": "inline"
                },
                "./rng": {
                  "where": "inline"
                },
                "./md5": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/buffer.js": {
            "requireId": "/__SYSTEM__/buffer",
            "memoizeId": "/__SYSTEM__/buffer.js",
            "descriptor": {
              "filename": "index.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify/index.js",
              "mtime": 1377529372,
              "code": "var assert;\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction Buffer(subject, encoding, offset) {\n  if(!assert) assert= require('assert');\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  // Work-around: node's base64 implementation\n  // allows for non-padded strings while base64-js\n  // does not..\n  if (encoding == \"base64\" && typeof subject == \"string\") {\n    subject = stringtrim(subject);\n    while (subject.length % 4 != 0) {\n      subject = subject + \"=\"; \n    }\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    // slicing works, with limitations (no parent tracking/update)\n    // check https://github.com/toots/buffer-browserify/issues/19\n    for (var i = 0; i < this.length; i++) {\n        this[i] = subject.get(i+offset);\n    }\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === 'number') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n    case 'binary':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n// slice(start, end)\nfunction clamp(index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n}\n\nBuffer.prototype.slice = function(start, end) {\n  var len = this.length;\n  start = clamp(start, len, 0);\n  end = clamp(end, len, len);\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nBuffer.isEncoding = function(encoding) {\n  switch ((encoding + '').toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == '[object Array]'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n",
              "globals": {
                "assert": {
                  "type": "assign"
                },
                "exports": {
                  "type": "reference"
                },
                "Buffer": {
                  "type": "reference"
                },
                "stringtrim": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "coerce": {
                  "type": "call"
                },
                "isArrayIsh": {
                  "type": "call"
                },
                "i": {
                  "type": "reference"
                },
                "utf8ToBytes": {
                  "type": "call"
                },
                "base64ToBytes": {
                  "type": "call"
                },
                "blitBuffer": {
                  "type": "call"
                },
                "asciiToBytes": {
                  "type": "call"
                },
                "Array": {
                  "type": "reference"
                },
                "decodeUtf8Char": {
                  "type": "call"
                },
                "String": {
                  "type": "reference"
                },
                "toHex": {
                  "type": "call"
                },
                "parseInt": {
                  "type": "call"
                },
                "isNaN": {
                  "type": "call"
                },
                "isFinite": {
                  "type": "call"
                },
                "clamp": {
                  "type": "assign"
                },
                "isArray": {
                  "type": "call"
                },
                "Math": {
                  "type": "reference"
                },
                "encodeURIComponent": {
                  "type": "call"
                },
                "decodeURIComponent": {
                  "type": "call"
                },
                "readUInt16": {
                  "type": "assign"
                },
                "readUInt32": {
                  "type": "assign"
                },
                "readInt16": {
                  "type": "assign"
                },
                "readInt32": {
                  "type": "assign"
                },
                "readFloat": {
                  "type": "assign"
                },
                "readDouble": {
                  "type": "assign"
                },
                "verifuint": {
                  "type": "assign"
                },
                "writeUInt16": {
                  "type": "assign"
                },
                "writeUInt32": {
                  "type": "assign"
                },
                "verifsint": {
                  "type": "assign"
                },
                "verifIEEE754": {
                  "type": "assign"
                },
                "writeInt16": {
                  "type": "assign"
                },
                "writeInt32": {
                  "type": "assign"
                },
                "writeFloat": {
                  "type": "assign"
                },
                "writeDouble": {
                  "type": "assign"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "assert": {
                    "where": "inline"
                  },
                  "base64-js": {
                    "where": "inline"
                  },
                  "./buffer_ieee754": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify';\nvar assert;\nexports.Buffer = Buffer;\nexports.SlowBuffer = Buffer;\nBuffer.poolSize = 8192;\nexports.INSPECT_MAX_BYTES = 50;\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction Buffer(subject, encoding, offset) {\n  if(!assert) assert= require('__SYSTEM__/assert');\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n  this.parent = this;\n  this.offset = 0;\n\n  // Work-around: node's base64 implementation\n  // allows for non-padded strings while base64-js\n  // does not..\n  if (encoding == \"base64\" && typeof subject == \"string\") {\n    subject = stringtrim(subject);\n    while (subject.length % 4 != 0) {\n      subject = subject + \"=\"; \n    }\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    // slicing works, with limitations (no parent tracking/update)\n    // check https://github.com/toots/buffer-browserify/issues/19\n    for (var i = 0; i < this.length; i++) {\n        this[i] = subject.get(i+offset);\n    }\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        if (subject instanceof Buffer) {\n          this[i] = subject.readUInt8(i);\n        }\n        else {\n          this[i] = subject[i];\n        }\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    } else if (type === 'number') {\n      for (var i = 0; i < this.length; i++) {\n        this[i] = 0;\n      }\n    }\n  }\n}\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this[i];\n};\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this[i] = v;\n};\n\nBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n    case 'binary':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;\n\nBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n};\n\nBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nBuffer.prototype.binarySlice = Buffer.prototype.asciiSlice;\n\nBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  Buffer._charsWritten = i * 2;\n  return i;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n// slice(start, end)\nfunction clamp(index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index;  // Coerce to integer.\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n}\n\nBuffer.prototype.slice = function(start, end) {\n  var len = this.length;\n  start = clamp(start, len, 0);\n  end = clamp(end, len, len);\n  return new Buffer(this, end - start, +start);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  if (end === undefined || isNaN(end)) {\n    end = this.length;\n  }\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  var temp = [];\n  for (var i=start; i<end; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=target_start; i<target_start+temp.length; i++) {\n    target[i] = temp[i-target_start];\n  }\n};\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  for (var i = start; i < end; i++) {\n    this[i] = value;\n  }\n}\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof Buffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nBuffer.isEncoding = function(encoding) {\n  switch ((encoding + '').toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\n// helpers\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\nfunction isArray(subject) {\n  return (Array.isArray ||\n    function(subject){\n      return {}.toString.apply(subject) == '[object Array]'\n    })\n    (subject)\n}\n\nfunction isArrayIsh(subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\n// read/write bit-twiddling\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  return buffer[offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    val = buffer[offset] << 8;\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1];\n    }\n  } else {\n    val = buffer[offset];\n    if (offset + 1 < buffer.length) {\n      val |= buffer[offset + 1] << 8;\n    }\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return 0;\n\n  if (isBigEndian) {\n    if (offset + 1 < buffer.length)\n      val = buffer[offset + 1] << 16;\n    if (offset + 2 < buffer.length)\n      val |= buffer[offset + 2] << 8;\n    if (offset + 3 < buffer.length)\n      val |= buffer[offset + 3];\n    val = val + (buffer[offset] << 24 >>> 0);\n  } else {\n    if (offset + 2 < buffer.length)\n      val = buffer[offset + 2] << 16;\n    if (offset + 1 < buffer.length)\n      val |= buffer[offset + 1] << 8;\n    val |= buffer[offset];\n    if (offset + 3 < buffer.length)\n      val = val + (buffer[offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (offset >= buffer.length) return;\n\n  neg = buffer[offset] & 0x80;\n  if (!neg) {\n    return (buffer[offset]);\n  }\n\n  return ((0xff - buffer[offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  if (offset < buffer.length) {\n    buffer[offset] = value;\n  }\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {\n    buffer[offset + i] =\n        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>\n            (isBigEndian ? 1 - i : i) * 8;\n  }\n\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {\n    buffer[offset + i] =\n        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {
                "assert": {
                  "where": "inline"
                },
                "base64-js": {
                  "where": "inline"
                },
                "./buffer_ieee754": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/assert.js": {
            "requireId": "/__SYSTEM__/assert",
            "memoizeId": "/__SYSTEM__/assert.js",
            "descriptor": {
              "filename": "assert.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin/assert.js",
              "mtime": 1379366460,
              "code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// UTILITY\nvar util = require('util');\nvar shims = require('_shims');\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  this.message = options.message || getMessage(this);\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = shims.keys(a),\n        kb = shims.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};",
              "globals": {
                "util": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "shims": {
                  "type": "assign"
                },
                "pSlice": {
                  "type": "assign"
                },
                "Array": {
                  "type": "reference"
                },
                "assert": {
                  "type": "assign"
                },
                "module": {
                  "type": "reference"
                },
                "getMessage": {
                  "type": "call"
                },
                "Error": {
                  "type": "reference"
                },
                "replacer": {
                  "type": "assign"
                },
                "isNaN": {
                  "type": "call"
                },
                "isFinite": {
                  "type": "call"
                },
                "truncate": {
                  "type": "assign"
                },
                "JSON": {
                  "type": "reference"
                },
                "fail": {
                  "type": "assign"
                },
                "ok": {
                  "type": "assign"
                },
                "_deepEqual": {
                  "type": "call"
                },
                "objEquiv": {
                  "type": "call"
                },
                "isArguments": {
                  "type": "assign"
                },
                "Object": {
                  "type": "reference"
                },
                "expectedException": {
                  "type": "assign"
                },
                "_throws": {
                  "type": "assign"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "util": {
                    "where": "inline"
                  },
                  "_shims": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// UTILITY\nvar util = require('__SYSTEM__/util');\nvar shims = require('_shims');\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  this.message = options.message || getMessage(this);\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = shims.keys(a),\n        kb = shims.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\nreturn {\n    util: (typeof util !== \"undefined\") ? util : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    shims: (typeof shims !== \"undefined\") ? shims : null,\n    pSlice: (typeof pSlice !== \"undefined\") ? pSlice : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    assert: (typeof assert !== \"undefined\") ? assert : null,\n    module: (typeof module !== \"undefined\") ? module : null,\n    getMessage: (typeof getMessage !== \"undefined\") ? getMessage : null,\n    Error: (typeof Error !== \"undefined\") ? Error : null,\n    replacer: (typeof replacer !== \"undefined\") ? replacer : null,\n    isNaN: (typeof isNaN !== \"undefined\") ? isNaN : null,\n    isFinite: (typeof isFinite !== \"undefined\") ? isFinite : null,\n    truncate: (typeof truncate !== \"undefined\") ? truncate : null,\n    JSON: (typeof JSON !== \"undefined\") ? JSON : null,\n    fail: (typeof fail !== \"undefined\") ? fail : null,\n    ok: (typeof ok !== \"undefined\") ? ok : null,\n    _deepEqual: (typeof _deepEqual !== \"undefined\") ? _deepEqual : null,\n    objEquiv: (typeof objEquiv !== \"undefined\") ? objEquiv : null,\n    isArguments: (typeof isArguments !== \"undefined\") ? isArguments : null,\n    Object: (typeof Object !== \"undefined\") ? Object : null,\n    expectedException: (typeof expectedException !== \"undefined\") ? expectedException : null,\n    _throws: (typeof _throws !== \"undefined\") ? _throws : null\n};\n}",
              "bottom": "return {\n    util: (typeof util !== \"undefined\") ? util : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    shims: (typeof shims !== \"undefined\") ? shims : null,\n    pSlice: (typeof pSlice !== \"undefined\") ? pSlice : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    assert: (typeof assert !== \"undefined\") ? assert : null,\n    module: (typeof module !== \"undefined\") ? module : null,\n    getMessage: (typeof getMessage !== \"undefined\") ? getMessage : null,\n    Error: (typeof Error !== \"undefined\") ? Error : null,\n    replacer: (typeof replacer !== \"undefined\") ? replacer : null,\n    isNaN: (typeof isNaN !== \"undefined\") ? isNaN : null,\n    isFinite: (typeof isFinite !== \"undefined\") ? isFinite : null,\n    truncate: (typeof truncate !== \"undefined\") ? truncate : null,\n    JSON: (typeof JSON !== \"undefined\") ? JSON : null,\n    fail: (typeof fail !== \"undefined\") ? fail : null,\n    ok: (typeof ok !== \"undefined\") ? ok : null,\n    _deepEqual: (typeof _deepEqual !== \"undefined\") ? _deepEqual : null,\n    objEquiv: (typeof objEquiv !== \"undefined\") ? objEquiv : null,\n    isArguments: (typeof isArguments !== \"undefined\") ? isArguments : null,\n    Object: (typeof Object !== \"undefined\") ? Object : null,\n    expectedException: (typeof expectedException !== \"undefined\") ? expectedException : null,\n    _throws: (typeof _throws !== \"undefined\") ? _throws : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "util": {
                  "where": "inline"
                },
                "_shims": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/util.js": {
            "requireId": "/__SYSTEM__/util",
            "memoizeId": "/__SYSTEM__/util.js",
            "descriptor": {
              "filename": "util.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin/util.js",
              "mtime": 1381856208,
              "code": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar shims = require('_shims');\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  shims.forEach(array, function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = shims.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = shims.getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  shims.forEach(keys, function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (shims.indexOf(ctx.seen, desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = shims.reduce(output, function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return shims.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.binarySlice === 'function'\n  ;\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = shims.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = shims.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n",
              "globals": {
                "shims": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "formatRegExp": {
                  "type": "assign"
                },
                "exports": {
                  "type": "reference"
                },
                "isString": {
                  "type": "call"
                },
                "inspect": {
                  "type": "call"
                },
                "String": {
                  "type": "call"
                },
                "Number": {
                  "type": "call"
                },
                "JSON": {
                  "type": "reference"
                },
                "isNull": {
                  "type": "call"
                },
                "x": {
                  "type": "reference"
                },
                "isObject": {
                  "type": "call"
                },
                "isBoolean": {
                  "type": "call"
                },
                "isUndefined": {
                  "type": "call"
                },
                "formatValue": {
                  "type": "call"
                },
                "stylizeWithColor": {
                  "type": "assign"
                },
                "stylizeNoColor": {
                  "type": "assign"
                },
                "arrayToHash": {
                  "type": "assign"
                },
                "isFunction": {
                  "type": "call"
                },
                "formatPrimitive": {
                  "type": "call"
                },
                "isRegExp": {
                  "type": "call"
                },
                "RegExp": {
                  "type": "reference"
                },
                "isDate": {
                  "type": "call"
                },
                "Date": {
                  "type": "reference"
                },
                "isError": {
                  "type": "call"
                },
                "formatError": {
                  "type": "call"
                },
                "isArray": {
                  "type": "call"
                },
                "formatArray": {
                  "type": "call"
                },
                "formatProperty": {
                  "type": "call"
                },
                "reduceToSingleString": {
                  "type": "call"
                },
                "isNumber": {
                  "type": "call"
                },
                "Error": {
                  "type": "reference"
                },
                "i": {
                  "type": "reference"
                },
                "isNullOrUndefined": {
                  "type": "assign"
                },
                "isSymbol": {
                  "type": "assign"
                },
                "objectToString": {
                  "type": "call"
                },
                "isPrimitive": {
                  "type": "assign"
                },
                "isBuffer": {
                  "type": "assign"
                },
                "Object": {
                  "type": "reference"
                },
                "pad": {
                  "type": "assign"
                },
                "months": {
                  "type": "assign"
                },
                "timestamp": {
                  "type": "assign"
                },
                "console": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "_shims": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar shims = require('_shims');\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  shims.forEach(array, function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = shims.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = shims.getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  shims.forEach(keys, function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (shims.indexOf(ctx.seen, desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = shims.reduce(output, function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return shims.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) && objectToString(e) === '[object Error]';\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.binarySlice === 'function'\n  ;\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = shims.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = shims.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {
                "_shims": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/_shims.js": {
            "requireId": "/__SYSTEM__/_shims",
            "memoizeId": "/__SYSTEM__/_shims.js",
            "descriptor": {
              "filename": "_shims.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin/_shims.js",
              "mtime": 1379366460,
              "code": "\n\n//\n// The shims in this file are not fully implemented shims for the ES5\n// features, but do work for the particular usecases there is in\n// the other modules.\n//\n\nvar toString = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n// Array.isArray is supported in IE9\nfunction isArray(xs) {\n  return toString.call(xs) === '[object Array]';\n}\nexports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;\n\n// Array.prototype.indexOf is supported in IE9\nexports.indexOf = function indexOf(xs, x) {\n  if (xs.indexOf) return xs.indexOf(x);\n  for (var i = 0; i < xs.length; i++) {\n    if (x === xs[i]) return i;\n  }\n  return -1;\n};\n\n// Array.prototype.filter is supported in IE9\nexports.filter = function filter(xs, fn) {\n  if (xs.filter) return xs.filter(fn);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (fn(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n};\n\n// Array.prototype.forEach is supported in IE9\nexports.forEach = function forEach(xs, fn, self) {\n  if (xs.forEach) return xs.forEach(fn, self);\n  for (var i = 0; i < xs.length; i++) {\n    fn.call(self, xs[i], i, xs);\n  }\n};\n\n// Array.prototype.map is supported in IE9\nexports.map = function map(xs, fn) {\n  if (xs.map) return xs.map(fn);\n  var out = new Array(xs.length);\n  for (var i = 0; i < xs.length; i++) {\n    out[i] = fn(xs[i], i, xs);\n  }\n  return out;\n};\n\n// Array.prototype.reduce is supported in IE9\nexports.reduce = function reduce(array, callback, opt_initialValue) {\n  if (array.reduce) return array.reduce(callback, opt_initialValue);\n  var value, isValueSet = false;\n\n  if (2 < arguments.length) {\n    value = opt_initialValue;\n    isValueSet = true;\n  }\n  for (var i = 0, l = array.length; l > i; ++i) {\n    if (array.hasOwnProperty(i)) {\n      if (isValueSet) {\n        value = callback(value, array[i], i, array);\n      }\n      else {\n        value = array[i];\n        isValueSet = true;\n      }\n    }\n  }\n\n  return value;\n};\n\n// String.prototype.substr - negative index don't work in IE8\nif ('ab'.substr(-1) !== 'b') {\n  exports.substr = function (str, start, length) {\n    // did we get a negative start, calculate how much it is from the beginning of the string\n    if (start < 0) start = str.length + start;\n\n    // call the original function\n    return str.substr(start, length);\n  };\n} else {\n  exports.substr = function (str, start, length) {\n    return str.substr(start, length);\n  };\n}\n\n// String.prototype.trim is supported in IE9\nexports.trim = function (str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n// Function.prototype.bind is supported in IE9\nexports.bind = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var fn = args.shift();\n  if (fn.bind) return fn.bind.apply(fn, args);\n  var self = args.shift();\n  return function () {\n    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));\n  };\n};\n\n// Object.create is supported in IE9\nfunction create(prototype, properties) {\n  var object;\n  if (prototype === null) {\n    object = { '__proto__' : null };\n  }\n  else {\n    if (typeof prototype !== 'object') {\n      throw new TypeError(\n        'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n      );\n    }\n    var Type = function () {};\n    Type.prototype = prototype;\n    object = new Type();\n    object.__proto__ = prototype;\n  }\n  if (typeof properties !== 'undefined' && Object.defineProperties) {\n    Object.defineProperties(object, properties);\n  }\n  return object;\n}\nexports.create = typeof Object.create === 'function' ? Object.create : create;\n\n// Object.keys and Object.getOwnPropertyNames is supported in IE9 however\n// they do show a description and number property on Error objects\nfunction notObject(object) {\n  return ((typeof object != \"object\" && typeof object != \"function\") || object === null);\n}\n\nfunction keysShim(object) {\n  if (notObject(object)) {\n    throw new TypeError(\"Object.keys called on a non-object\");\n  }\n\n  var result = [];\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// getOwnPropertyNames is almost the same as Object.keys one key feature\n//  is that it returns hidden properties, since that can't be implemented,\n//  this feature gets reduced so it just shows the length property on arrays\nfunction propertyShim(object) {\n  if (notObject(object)) {\n    throw new TypeError(\"Object.getOwnPropertyNames called on a non-object\");\n  }\n\n  var result = keysShim(object);\n  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {\n    result.push('length');\n  }\n  return result;\n}\n\nvar keys = typeof Object.keys === 'function' ? Object.keys : keysShim;\nvar getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?\n  Object.getOwnPropertyNames : propertyShim;\n\nif (new Error().hasOwnProperty('description')) {\n  var ERROR_PROPERTY_FILTER = function (obj, array) {\n    if (toString.call(obj) === '[object Error]') {\n      array = exports.filter(array, function (name) {\n        return name !== 'description' && name !== 'number' && name !== 'message';\n      });\n    }\n    return array;\n  };\n\n  exports.keys = function (object) {\n    return ERROR_PROPERTY_FILTER(object, keys(object));\n  };\n  exports.getOwnPropertyNames = function (object) {\n    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));\n  };\n} else {\n  exports.keys = keys;\n  exports.getOwnPropertyNames = getOwnPropertyNames;\n}\n\n// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements\nfunction valueObject(value, key) {\n  return { value: value[key] };\n}\n\nif (typeof Object.getOwnPropertyDescriptor === 'function') {\n  try {\n    Object.getOwnPropertyDescriptor({'a': 1}, 'a');\n    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  } catch (e) {\n    // IE8 dom element issue - use a try catch and default to valueObject\n    exports.getOwnPropertyDescriptor = function (value, key) {\n      try {\n        return Object.getOwnPropertyDescriptor(value, key);\n      } catch (e) {\n        return valueObject(value, key);\n      }\n    };\n  }\n} else {\n  exports.getOwnPropertyDescriptor = valueObject;\n}\n",
              "globals": {
                "Object": {
                  "type": "reference"
                },
                "isArray": {
                  "type": "assign"
                },
                "exports": {
                  "type": "reference"
                },
                "Array": {
                  "type": "reference"
                },
                "i": {
                  "type": "reference"
                },
                "create": {
                  "type": "assign"
                },
                "notObject": {
                  "type": "assign"
                },
                "keysShim": {
                  "type": "assign"
                },
                "propertyShim": {
                  "type": "assign"
                },
                "keys": {
                  "type": "assign"
                },
                "getOwnPropertyNames": {
                  "type": "assign"
                },
                "ERROR_PROPERTY_FILTER": {
                  "type": "assign"
                },
                "valueObject": {
                  "type": "assign"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {},
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/builtin';\n\n\n//\n// The shims in this file are not fully implemented shims for the ES5\n// features, but do work for the particular usecases there is in\n// the other modules.\n//\n\nvar toString = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n// Array.isArray is supported in IE9\nfunction isArray(xs) {\n  return toString.call(xs) === '[object Array]';\n}\nexports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;\n\n// Array.prototype.indexOf is supported in IE9\nexports.indexOf = function indexOf(xs, x) {\n  if (xs.indexOf) return xs.indexOf(x);\n  for (var i = 0; i < xs.length; i++) {\n    if (x === xs[i]) return i;\n  }\n  return -1;\n};\n\n// Array.prototype.filter is supported in IE9\nexports.filter = function filter(xs, fn) {\n  if (xs.filter) return xs.filter(fn);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    if (fn(xs[i], i, xs)) res.push(xs[i]);\n  }\n  return res;\n};\n\n// Array.prototype.forEach is supported in IE9\nexports.forEach = function forEach(xs, fn, self) {\n  if (xs.forEach) return xs.forEach(fn, self);\n  for (var i = 0; i < xs.length; i++) {\n    fn.call(self, xs[i], i, xs);\n  }\n};\n\n// Array.prototype.map is supported in IE9\nexports.map = function map(xs, fn) {\n  if (xs.map) return xs.map(fn);\n  var out = new Array(xs.length);\n  for (var i = 0; i < xs.length; i++) {\n    out[i] = fn(xs[i], i, xs);\n  }\n  return out;\n};\n\n// Array.prototype.reduce is supported in IE9\nexports.reduce = function reduce(array, callback, opt_initialValue) {\n  if (array.reduce) return array.reduce(callback, opt_initialValue);\n  var value, isValueSet = false;\n\n  if (2 < arguments.length) {\n    value = opt_initialValue;\n    isValueSet = true;\n  }\n  for (var i = 0, l = array.length; l > i; ++i) {\n    if (array.hasOwnProperty(i)) {\n      if (isValueSet) {\n        value = callback(value, array[i], i, array);\n      }\n      else {\n        value = array[i];\n        isValueSet = true;\n      }\n    }\n  }\n\n  return value;\n};\n\n// String.prototype.substr - negative index don't work in IE8\nif ('ab'.substr(-1) !== 'b') {\n  exports.substr = function (str, start, length) {\n    // did we get a negative start, calculate how much it is from the beginning of the string\n    if (start < 0) start = str.length + start;\n\n    // call the original function\n    return str.substr(start, length);\n  };\n} else {\n  exports.substr = function (str, start, length) {\n    return str.substr(start, length);\n  };\n}\n\n// String.prototype.trim is supported in IE9\nexports.trim = function (str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n// Function.prototype.bind is supported in IE9\nexports.bind = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var fn = args.shift();\n  if (fn.bind) return fn.bind.apply(fn, args);\n  var self = args.shift();\n  return function () {\n    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));\n  };\n};\n\n// Object.create is supported in IE9\nfunction create(prototype, properties) {\n  var object;\n  if (prototype === null) {\n    object = { '__proto__' : null };\n  }\n  else {\n    if (typeof prototype !== 'object') {\n      throw new TypeError(\n        'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n      );\n    }\n    var Type = function () {};\n    Type.prototype = prototype;\n    object = new Type();\n    object.__proto__ = prototype;\n  }\n  if (typeof properties !== 'undefined' && Object.defineProperties) {\n    Object.defineProperties(object, properties);\n  }\n  return object;\n}\nexports.create = typeof Object.create === 'function' ? Object.create : create;\n\n// Object.keys and Object.getOwnPropertyNames is supported in IE9 however\n// they do show a description and number property on Error objects\nfunction notObject(object) {\n  return ((typeof object != \"object\" && typeof object != \"function\") || object === null);\n}\n\nfunction keysShim(object) {\n  if (notObject(object)) {\n    throw new TypeError(\"Object.keys called on a non-object\");\n  }\n\n  var result = [];\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result.push(name);\n    }\n  }\n  return result;\n}\n\n// getOwnPropertyNames is almost the same as Object.keys one key feature\n//  is that it returns hidden properties, since that can't be implemented,\n//  this feature gets reduced so it just shows the length property on arrays\nfunction propertyShim(object) {\n  if (notObject(object)) {\n    throw new TypeError(\"Object.getOwnPropertyNames called on a non-object\");\n  }\n\n  var result = keysShim(object);\n  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {\n    result.push('length');\n  }\n  return result;\n}\n\nvar keys = typeof Object.keys === 'function' ? Object.keys : keysShim;\nvar getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?\n  Object.getOwnPropertyNames : propertyShim;\n\nif (new Error().hasOwnProperty('description')) {\n  var ERROR_PROPERTY_FILTER = function (obj, array) {\n    if (toString.call(obj) === '[object Error]') {\n      array = exports.filter(array, function (name) {\n        return name !== 'description' && name !== 'number' && name !== 'message';\n      });\n    }\n    return array;\n  };\n\n  exports.keys = function (object) {\n    return ERROR_PROPERTY_FILTER(object, keys(object));\n  };\n  exports.getOwnPropertyNames = function (object) {\n    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));\n  };\n} else {\n  exports.keys = keys;\n  exports.getOwnPropertyNames = getOwnPropertyNames;\n}\n\n// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements\nfunction valueObject(value, key) {\n  return { value: value[key] };\n}\n\nif (typeof Object.getOwnPropertyDescriptor === 'function') {\n  try {\n    Object.getOwnPropertyDescriptor({'a': 1}, 'a');\n    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  } catch (e) {\n    // IE8 dom element issue - use a try catch and default to valueObject\n    exports.getOwnPropertyDescriptor = function (value, key) {\n      try {\n        return Object.getOwnPropertyDescriptor(value, key);\n      } catch (e) {\n        return valueObject(value, key);\n      }\n    };\n  }\n} else {\n  exports.getOwnPropertyDescriptor = valueObject;\n}\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {},
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/buffer_ieee754.js": {
            "requireId": "/__SYSTEM__/buffer_ieee754",
            "memoizeId": "/__SYSTEM__/buffer_ieee754.js",
            "descriptor": {
              "filename": "buffer_ieee754.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify/buffer_ieee754.js",
              "mtime": 1342393862,
              "code": "exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n",
              "globals": {
                "exports": {
                  "type": "reference"
                },
                "Math": {
                  "type": "reference"
                },
                "isNaN": {
                  "type": "call"
                }
              },
              "syntax": "javascript",
              "format": "commonjs",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {},
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/buffer-browserify';\nexports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n}",
              "bottom": "}"
            },
            "dependencies": {
              "static": {},
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/sha.js": {
            "requireId": "/__SYSTEM__/sha",
            "memoizeId": "/__SYSTEM__/sha.js",
            "descriptor": {
              "filename": "sha.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/sha.js",
              "mtime": 1384879954,
              "code": "/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar helpers = require('./helpers');\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n",
              "globals": {
                "helpers": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "core_sha1": {
                  "type": "assign"
                },
                "Array": {
                  "type": "call"
                },
                "rol": {
                  "type": "call"
                },
                "safe_add": {
                  "type": "call"
                },
                "sha1_ft": {
                  "type": "call"
                },
                "j": {
                  "type": "reference"
                },
                "sha1_kt": {
                  "type": "call"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "./helpers": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar helpers = require('./helpers');\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n\nreturn {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    core_sha1: (typeof core_sha1 !== \"undefined\") ? core_sha1 : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    rol: (typeof rol !== \"undefined\") ? rol : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    sha1_ft: (typeof sha1_ft !== \"undefined\") ? sha1_ft : null,\n    j: (typeof j !== \"undefined\") ? j : null,\n    sha1_kt: (typeof sha1_kt !== \"undefined\") ? sha1_kt : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    core_sha1: (typeof core_sha1 !== \"undefined\") ? core_sha1 : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    rol: (typeof rol !== \"undefined\") ? rol : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    sha1_ft: (typeof sha1_ft !== \"undefined\") ? sha1_ft : null,\n    j: (typeof j !== \"undefined\") ? j : null,\n    sha1_kt: (typeof sha1_kt !== \"undefined\") ? sha1_kt : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "./helpers": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/helpers.js": {
            "requireId": "/__SYSTEM__/helpers",
            "memoizeId": "/__SYSTEM__/helpers.js",
            "descriptor": {
              "filename": "helpers.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/helpers.js",
              "mtime": 1383545597,
              "code": "var Buffer = require('buffer').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n",
              "globals": {
                "Buffer": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "intSize": {
                  "type": "assign"
                },
                "zeroBuffer": {
                  "type": "assign"
                },
                "chrsz": {
                  "type": "assign"
                },
                "toArray": {
                  "type": "assign"
                },
                "i": {
                  "type": "reference"
                },
                "toBuffer": {
                  "type": "assign"
                },
                "hash": {
                  "type": "assign"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "buffer": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\nvar Buffer = require('__SYSTEM__/buffer').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\nreturn {\n    Buffer: (typeof Buffer !== \"undefined\") ? Buffer : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    intSize: (typeof intSize !== \"undefined\") ? intSize : null,\n    zeroBuffer: (typeof zeroBuffer !== \"undefined\") ? zeroBuffer : null,\n    chrsz: (typeof chrsz !== \"undefined\") ? chrsz : null,\n    toArray: (typeof toArray !== \"undefined\") ? toArray : null,\n    i: (typeof i !== \"undefined\") ? i : null,\n    toBuffer: (typeof toBuffer !== \"undefined\") ? toBuffer : null,\n    hash: (typeof hash !== \"undefined\") ? hash : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    Buffer: (typeof Buffer !== \"undefined\") ? Buffer : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    intSize: (typeof intSize !== \"undefined\") ? intSize : null,\n    zeroBuffer: (typeof zeroBuffer !== \"undefined\") ? zeroBuffer : null,\n    chrsz: (typeof chrsz !== \"undefined\") ? chrsz : null,\n    toArray: (typeof toArray !== \"undefined\") ? toArray : null,\n    i: (typeof i !== \"undefined\") ? i : null,\n    toBuffer: (typeof toBuffer !== \"undefined\") ? toBuffer : null,\n    hash: (typeof hash !== \"undefined\") ? hash : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "buffer": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/sha256.js": {
            "requireId": "/__SYSTEM__/sha256",
            "memoizeId": "/__SYSTEM__/sha256.js",
            "descriptor": {
              "filename": "sha256.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/sha256.js",
              "mtime": 1383545597,
              "code": "\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar helpers = require('./helpers');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  /* append padding */\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n",
              "globals": {
                "helpers": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "safe_add": {
                  "type": "assign"
                },
                "S": {
                  "type": "assign"
                },
                "R": {
                  "type": "assign"
                },
                "Ch": {
                  "type": "assign"
                },
                "Maj": {
                  "type": "assign"
                },
                "Sigma0256": {
                  "type": "assign"
                },
                "Sigma1256": {
                  "type": "assign"
                },
                "Gamma0256": {
                  "type": "assign"
                },
                "Gamma1256": {
                  "type": "assign"
                },
                "core_sha256": {
                  "type": "assign"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "./helpers": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\n\n/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar helpers = require('./helpers');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  /* append padding */\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n\nreturn {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    S: (typeof S !== \"undefined\") ? S : null,\n    R: (typeof R !== \"undefined\") ? R : null,\n    Ch: (typeof Ch !== \"undefined\") ? Ch : null,\n    Maj: (typeof Maj !== \"undefined\") ? Maj : null,\n    Sigma0256: (typeof Sigma0256 !== \"undefined\") ? Sigma0256 : null,\n    Sigma1256: (typeof Sigma1256 !== \"undefined\") ? Sigma1256 : null,\n    Gamma0256: (typeof Gamma0256 !== \"undefined\") ? Gamma0256 : null,\n    Gamma1256: (typeof Gamma1256 !== \"undefined\") ? Gamma1256 : null,\n    core_sha256: (typeof core_sha256 !== \"undefined\") ? core_sha256 : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    S: (typeof S !== \"undefined\") ? S : null,\n    R: (typeof R !== \"undefined\") ? R : null,\n    Ch: (typeof Ch !== \"undefined\") ? Ch : null,\n    Maj: (typeof Maj !== \"undefined\") ? Maj : null,\n    Sigma0256: (typeof Sigma0256 !== \"undefined\") ? Sigma0256 : null,\n    Sigma1256: (typeof Sigma1256 !== \"undefined\") ? Sigma1256 : null,\n    Gamma0256: (typeof Gamma0256 !== \"undefined\") ? Gamma0256 : null,\n    Gamma1256: (typeof Gamma1256 !== \"undefined\") ? Gamma1256 : null,\n    core_sha256: (typeof core_sha256 !== \"undefined\") ? core_sha256 : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "./helpers": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/rng.js": {
            "requireId": "/__SYSTEM__/rng",
            "memoizeId": "/__SYSTEM__/rng.js",
            "descriptor": {
              "filename": "rng.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/rng.js",
              "mtime": 1385529373,
              "code": "// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n",
              "globals": {
                "Math": {
                  "type": "reference"
                },
                "crypto": {
                  "type": "reference"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {},
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\n// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n\nreturn {\n    Math: (typeof Math !== \"undefined\") ? Math : null,\n    crypto: (typeof crypto !== \"undefined\") ? crypto : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    Math: (typeof Math !== \"undefined\") ? Math : null,\n    crypto: (typeof crypto !== \"undefined\") ? crypto : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {},
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/__SYSTEM__/md5.js": {
            "requireId": "/__SYSTEM__/md5",
            "memoizeId": "/__SYSTEM__/md5.js",
            "descriptor": {
              "filename": "md5.js",
              "filepath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify/md5.js",
              "mtime": 1383545597,
              "code": "/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\nvar helpers = require('./helpers');\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction md5_vm_test()\r\n{\r\n  return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length\r\n */\r\nfunction core_md5(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << ((len) % 32);\r\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n\r\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\r\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\r\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\r\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\r\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\r\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\r\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\r\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\r\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\r\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\r\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\r\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\r\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\r\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\r\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\r\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\r\n\r\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\r\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\r\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\r\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\r\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\r\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\r\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\r\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\r\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\r\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\r\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\r\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\r\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\r\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\r\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\r\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\r\n\r\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\r\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\r\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\r\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\r\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\r\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\r\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\r\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\r\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\r\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\r\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\r\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\r\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\r\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\r\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\r\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\r\n\r\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\r\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\r\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\r\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\r\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\r\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\r\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\r\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\r\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\r\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\r\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\r\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\r\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\r\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\r\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\r\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n  }\r\n  return Array(a, b, c, d);\r\n\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t)\r\n{\r\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nmodule.exports = function md5(buf) {\r\n  return helpers.hash(buf, core_md5, 16);\r\n};\r\n",
              "globals": {
                "helpers": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "md5_vm_test": {
                  "type": "assign"
                },
                "hex_md5": {
                  "type": "call"
                },
                "core_md5": {
                  "type": "assign"
                },
                "md5_ff": {
                  "type": "call"
                },
                "md5_gg": {
                  "type": "call"
                },
                "md5_hh": {
                  "type": "call"
                },
                "md5_ii": {
                  "type": "call"
                },
                "safe_add": {
                  "type": "call"
                },
                "Array": {
                  "type": "call"
                },
                "md5_cmn": {
                  "type": "assign"
                },
                "bit_rol": {
                  "type": "call"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "./helpers": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';",
              "code": "function(require, exports, module) {var __dirname = 'playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/node_modules/pinf-for-nodejs/node_modules/pinf-it-bundler/node_modules/browser-builtins/node_modules/crypto-browserify';\n/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\nvar helpers = require('./helpers');\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction md5_vm_test()\r\n{\r\n  return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length\r\n */\r\nfunction core_md5(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << ((len) % 32);\r\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n\r\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\r\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\r\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\r\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\r\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\r\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\r\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\r\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\r\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\r\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\r\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\r\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\r\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\r\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\r\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\r\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\r\n\r\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\r\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\r\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\r\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\r\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\r\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\r\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\r\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\r\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\r\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\r\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\r\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\r\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\r\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\r\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\r\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\r\n\r\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\r\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\r\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\r\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\r\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\r\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\r\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\r\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\r\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\r\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\r\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\r\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\r\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\r\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\r\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\r\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\r\n\r\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\r\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\r\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\r\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\r\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\r\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\r\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\r\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\r\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\r\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\r\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\r\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\r\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\r\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\r\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\r\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n  }\r\n  return Array(a, b, c, d);\r\n\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t)\r\n{\r\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t)\r\n{\r\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nmodule.exports = function md5(buf) {\r\n  return helpers.hash(buf, core_md5, 16);\r\n};\r\n\nreturn {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    md5_vm_test: (typeof md5_vm_test !== \"undefined\") ? md5_vm_test : null,\n    hex_md5: (typeof hex_md5 !== \"undefined\") ? hex_md5 : null,\n    core_md5: (typeof core_md5 !== \"undefined\") ? core_md5 : null,\n    md5_ff: (typeof md5_ff !== \"undefined\") ? md5_ff : null,\n    md5_gg: (typeof md5_gg !== \"undefined\") ? md5_gg : null,\n    md5_hh: (typeof md5_hh !== \"undefined\") ? md5_hh : null,\n    md5_ii: (typeof md5_ii !== \"undefined\") ? md5_ii : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    md5_cmn: (typeof md5_cmn !== \"undefined\") ? md5_cmn : null,\n    bit_rol: (typeof bit_rol !== \"undefined\") ? bit_rol : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    helpers: (typeof helpers !== \"undefined\") ? helpers : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    md5_vm_test: (typeof md5_vm_test !== \"undefined\") ? md5_vm_test : null,\n    hex_md5: (typeof hex_md5 !== \"undefined\") ? hex_md5 : null,\n    core_md5: (typeof core_md5 !== \"undefined\") ? core_md5 : null,\n    md5_ff: (typeof md5_ff !== \"undefined\") ? md5_ff : null,\n    md5_gg: (typeof md5_gg !== \"undefined\") ? md5_gg : null,\n    md5_hh: (typeof md5_hh !== \"undefined\") ? md5_hh : null,\n    md5_ii: (typeof md5_ii !== \"undefined\") ? md5_ii : null,\n    safe_add: (typeof safe_add !== \"undefined\") ? safe_add : null,\n    Array: (typeof Array !== \"undefined\") ? Array : null,\n    md5_cmn: (typeof md5_cmn !== \"undefined\") ? md5_cmn : null,\n    bit_rol: (typeof bit_rol !== \"undefined\") ? bit_rol : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "./helpers": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/ecc.js": {
            "requireId": "/ecc",
            "memoizeId": "/ecc.js",
            "descriptor": {
              "filename": "ecc.js",
              "filepath": "ecc.js",
              "mtime": 1407311739,
              "code": "\n// @source https://github.com/jpillora/eccjs/blob/11fece9ad4419be74a270095b1391da4d76c25e8/src/ecc.js\n\nconst SJCL = require(\"sjcl\");\n\nvar ecc = {},\n    DEFAULT_CURVE = 192,\n    ENC_DEC = ecc.ENC_DEC = {},\n    SIG_VER = ecc.SIG_VER = {},\n    elg = eccAPI('elGamal'),\n    dsa = eccAPI('ecdsa'),\n    sha256 = hashAPI('sha256');\n\necc.sjcl = SJCL;\n\necc.generate = function(type, curve) {\n  if(!curve)\n    curve = DEFAULT_CURVE;\n  var keys, pub, sec;\n  if(type === ENC_DEC) {\n    pub = 'enc';\n    sec = 'dec';\n    keys = elg.generate(curve);\n  } else if(type === SIG_VER) {\n    pub = 'ver';\n    sec = 'sig';\n    keys = dsa.generate(curve);\n  } else\n    throw \"eccjs: generate: Unknown type\";\n\n  var newkeys = {};\n  newkeys[pub] = exportPublic(keys.pub);\n  newkeys[sec] = exportSecret(keys.sec);\n  return newkeys;\n};\n\nvar cache = {\n  enc: {}, dec: {}, sig: {}, ver: {}\n};\n\necc.encrypt = function(enckey, plaintext) {\n  var kem = cache.enc[enckey];\n\n  if(!kem) {\n    kem = cache.enc[enckey] = elg.importPublic(enckey).kem();\n    kem.tagHex = SJCL.codec.hex.fromBits(kem.tag);\n  }\n\n  var obj = SJCL.json._encrypt(kem.key, plaintext);\n  obj.tag = kem.tagHex;\n\n  return JSON.stringify(obj);\n};\n\n\necc.decrypt = function(deckey, ciphertext) {\n  var obj = JSON.parse(ciphertext);\n\n  var kem = cache.dec[deckey];\n  if(!kem) {\n    kem = cache.dec[deckey] = elg.importSecret(deckey);\n    kem.$keys = {};\n  }\n\n  var key = kem.$keys[obj.tag];\n  if(!key)\n    key = kem.$keys[obj.tag] = kem.unkem(SJCL.codec.hex.toBits(obj.tag));\n\n  return SJCL.json._decrypt(key, obj);\n};\n\necc.sign = function(sigkey, text, hash) {\n  var key = cache.sig[sigkey];\n  if(!key)\n    key = cache.sig[sigkey] = dsa.importSecret(sigkey);\n\n  //hash first\n  if(hash !== false)\n    text = sha256.hash(text);\n\n  return key.sign(text);\n};\n\necc.verify = function(verkey, signature, text, hash) {\n  var key = cache.ver[verkey];\n  if(!key)\n    key = cache.ver[verkey] = dsa.importPublic(verkey);\n\n  //hash first\n  if(hash !== false)\n    text = sha256.hash(text);\n\n  try {\n    return key.verify(text, signature);\n  } catch(e) {\n    return false;\n  }\n};\n\n\n//ecc algorithm helpers\nfunction eccAPI(algoName) {\n  var algo = SJCL.ecc[algoName];\n  if(!algo)\n    throw new Error(\"Missing ECC algorithm: \" + algoName);\n  return {\n    generate: function(curve) {\n      var keys = algo.generateKeys(curve, 1);\n      keys.pub.$curve = curve;\n      keys.sec.$curve = curve;\n      return keys;\n    },\n    importPublic: function(keyStr) {\n      var key = extract(keyStr);\n      return new algo.publicKey(key.curve, SJCL.codec.hex.toBits(key.hex));\n    },\n    importSecret: function(keyStr) {\n      var key = extract(keyStr);\n      return new algo.secretKey(key.curve, new SJCL.bn(key.hex));\n    }\n  };\n}\n\nfunction extract(str) {\n  return {\n    curve: SJCL.ecc.curves['c'+str.substr(0, 3)],\n    hex: str.substr(3)\n  };\n}\n\nfunction exportPublic(keyObj) {\n  var obj = keyObj.get();\n  return keyObj.$curve +\n         SJCL.codec.hex.fromBits(obj.x) +\n         SJCL.codec.hex.fromBits(obj.y);\n}\nfunction exportSecret(keyObj) {\n  return keyObj.$curve + SJCL.codec.hex.fromBits(keyObj.get());\n}\n\n//hash algorithm helpers\nfunction hashAPI(algoName) {\n  var algo = SJCL.hash[algoName];\n  if(!algo)\n    throw new Error(\"Missing hash algorithm: \" + algoName);\n  return {\n    hash: function(input) {\n      return algo.hash(input);\n    }\n  };\n}\n\nmodule.exports = ecc;\n",
              "globals": {
                "SJCL": {
                  "type": "assign"
                },
                "require": {
                  "type": "call"
                },
                "ecc": {
                  "type": "assign"
                },
                "DEFAULT_CURVE": {
                  "type": "assign"
                },
                "ENC_DEC": {
                  "type": "assign"
                },
                "SIG_VER": {
                  "type": "assign"
                },
                "elg": {
                  "type": "assign"
                },
                "eccAPI": {
                  "type": "call"
                },
                "dsa": {
                  "type": "assign"
                },
                "sha256": {
                  "type": "assign"
                },
                "hashAPI": {
                  "type": "call"
                },
                "exportPublic": {
                  "type": "call"
                },
                "exportSecret": {
                  "type": "call"
                },
                "cache": {
                  "type": "assign"
                },
                "JSON": {
                  "type": "reference"
                },
                "extract": {
                  "type": "call"
                },
                "module": {
                  "type": "reference"
                }
              },
              "syntax": "javascript",
              "format": "leaky",
              "undefine": [],
              "uses": {},
              "dependencies": {
                "static": {
                  "sjcl": {
                    "where": "inline"
                  }
                },
                "dynamic": {},
                "computed": false
              }
            },
            "wrapper": {
              "type": "commonjs/leaky",
              "top": "function(require, exports, module) {var __dirname = '';",
              "code": "function(require, exports, module) {var __dirname = '';\n\n// @source https://github.com/jpillora/eccjs/blob/11fece9ad4419be74a270095b1391da4d76c25e8/src/ecc.js\n\nconst SJCL = require(\"sjcl\");\n\nvar ecc = {},\n    DEFAULT_CURVE = 192,\n    ENC_DEC = ecc.ENC_DEC = {},\n    SIG_VER = ecc.SIG_VER = {},\n    elg = eccAPI('elGamal'),\n    dsa = eccAPI('ecdsa'),\n    sha256 = hashAPI('sha256');\n\necc.sjcl = SJCL;\n\necc.generate = function(type, curve) {\n  if(!curve)\n    curve = DEFAULT_CURVE;\n  var keys, pub, sec;\n  if(type === ENC_DEC) {\n    pub = 'enc';\n    sec = 'dec';\n    keys = elg.generate(curve);\n  } else if(type === SIG_VER) {\n    pub = 'ver';\n    sec = 'sig';\n    keys = dsa.generate(curve);\n  } else\n    throw \"eccjs: generate: Unknown type\";\n\n  var newkeys = {};\n  newkeys[pub] = exportPublic(keys.pub);\n  newkeys[sec] = exportSecret(keys.sec);\n  return newkeys;\n};\n\nvar cache = {\n  enc: {}, dec: {}, sig: {}, ver: {}\n};\n\necc.encrypt = function(enckey, plaintext) {\n  var kem = cache.enc[enckey];\n\n  if(!kem) {\n    kem = cache.enc[enckey] = elg.importPublic(enckey).kem();\n    kem.tagHex = SJCL.codec.hex.fromBits(kem.tag);\n  }\n\n  var obj = SJCL.json._encrypt(kem.key, plaintext);\n  obj.tag = kem.tagHex;\n\n  return JSON.stringify(obj);\n};\n\n\necc.decrypt = function(deckey, ciphertext) {\n  var obj = JSON.parse(ciphertext);\n\n  var kem = cache.dec[deckey];\n  if(!kem) {\n    kem = cache.dec[deckey] = elg.importSecret(deckey);\n    kem.$keys = {};\n  }\n\n  var key = kem.$keys[obj.tag];\n  if(!key)\n    key = kem.$keys[obj.tag] = kem.unkem(SJCL.codec.hex.toBits(obj.tag));\n\n  return SJCL.json._decrypt(key, obj);\n};\n\necc.sign = function(sigkey, text, hash) {\n  var key = cache.sig[sigkey];\n  if(!key)\n    key = cache.sig[sigkey] = dsa.importSecret(sigkey);\n\n  //hash first\n  if(hash !== false)\n    text = sha256.hash(text);\n\n  return key.sign(text);\n};\n\necc.verify = function(verkey, signature, text, hash) {\n  var key = cache.ver[verkey];\n  if(!key)\n    key = cache.ver[verkey] = dsa.importPublic(verkey);\n\n  //hash first\n  if(hash !== false)\n    text = sha256.hash(text);\n\n  try {\n    return key.verify(text, signature);\n  } catch(e) {\n    return false;\n  }\n};\n\n\n//ecc algorithm helpers\nfunction eccAPI(algoName) {\n  var algo = SJCL.ecc[algoName];\n  if(!algo)\n    throw new Error(\"Missing ECC algorithm: \" + algoName);\n  return {\n    generate: function(curve) {\n      var keys = algo.generateKeys(curve, 1);\n      keys.pub.$curve = curve;\n      keys.sec.$curve = curve;\n      return keys;\n    },\n    importPublic: function(keyStr) {\n      var key = extract(keyStr);\n      return new algo.publicKey(key.curve, SJCL.codec.hex.toBits(key.hex));\n    },\n    importSecret: function(keyStr) {\n      var key = extract(keyStr);\n      return new algo.secretKey(key.curve, new SJCL.bn(key.hex));\n    }\n  };\n}\n\nfunction extract(str) {\n  return {\n    curve: SJCL.ecc.curves['c'+str.substr(0, 3)],\n    hex: str.substr(3)\n  };\n}\n\nfunction exportPublic(keyObj) {\n  var obj = keyObj.get();\n  return keyObj.$curve +\n         SJCL.codec.hex.fromBits(obj.x) +\n         SJCL.codec.hex.fromBits(obj.y);\n}\nfunction exportSecret(keyObj) {\n  return keyObj.$curve + SJCL.codec.hex.fromBits(keyObj.get());\n}\n\n//hash algorithm helpers\nfunction hashAPI(algoName) {\n  var algo = SJCL.hash[algoName];\n  if(!algo)\n    throw new Error(\"Missing hash algorithm: \" + algoName);\n  return {\n    hash: function(input) {\n      return algo.hash(input);\n    }\n  };\n}\n\nmodule.exports = ecc;\n\nreturn {\n    SJCL: (typeof SJCL !== \"undefined\") ? SJCL : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    ecc: (typeof ecc !== \"undefined\") ? ecc : null,\n    DEFAULT_CURVE: (typeof DEFAULT_CURVE !== \"undefined\") ? DEFAULT_CURVE : null,\n    ENC_DEC: (typeof ENC_DEC !== \"undefined\") ? ENC_DEC : null,\n    SIG_VER: (typeof SIG_VER !== \"undefined\") ? SIG_VER : null,\n    elg: (typeof elg !== \"undefined\") ? elg : null,\n    eccAPI: (typeof eccAPI !== \"undefined\") ? eccAPI : null,\n    dsa: (typeof dsa !== \"undefined\") ? dsa : null,\n    sha256: (typeof sha256 !== \"undefined\") ? sha256 : null,\n    hashAPI: (typeof hashAPI !== \"undefined\") ? hashAPI : null,\n    exportPublic: (typeof exportPublic !== \"undefined\") ? exportPublic : null,\n    exportSecret: (typeof exportSecret !== \"undefined\") ? exportSecret : null,\n    cache: (typeof cache !== \"undefined\") ? cache : null,\n    JSON: (typeof JSON !== \"undefined\") ? JSON : null,\n    extract: (typeof extract !== \"undefined\") ? extract : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}",
              "bottom": "return {\n    SJCL: (typeof SJCL !== \"undefined\") ? SJCL : null,\n    require: (typeof require !== \"undefined\") ? require : null,\n    ecc: (typeof ecc !== \"undefined\") ? ecc : null,\n    DEFAULT_CURVE: (typeof DEFAULT_CURVE !== \"undefined\") ? DEFAULT_CURVE : null,\n    ENC_DEC: (typeof ENC_DEC !== \"undefined\") ? ENC_DEC : null,\n    SIG_VER: (typeof SIG_VER !== \"undefined\") ? SIG_VER : null,\n    elg: (typeof elg !== \"undefined\") ? elg : null,\n    eccAPI: (typeof eccAPI !== \"undefined\") ? eccAPI : null,\n    dsa: (typeof dsa !== \"undefined\") ? dsa : null,\n    sha256: (typeof sha256 !== \"undefined\") ? sha256 : null,\n    hashAPI: (typeof hashAPI !== \"undefined\") ? hashAPI : null,\n    exportPublic: (typeof exportPublic !== \"undefined\") ? exportPublic : null,\n    exportSecret: (typeof exportSecret !== \"undefined\") ? exportSecret : null,\n    cache: (typeof cache !== \"undefined\") ? cache : null,\n    JSON: (typeof JSON !== \"undefined\") ? JSON : null,\n    extract: (typeof extract !== \"undefined\") ? extract : null,\n    module: (typeof module !== \"undefined\") ? module : null\n};\n}"
            },
            "dependencies": {
              "static": {
                "sjcl": {
                  "where": "inline"
                }
              },
              "dynamic": {},
              "computed": false
            },
            "warnings": [],
            "errors": []
          },
          "/package.json": {
            "requireId": "/package.json",
            "memoizeId": "/package.json",
            "descriptor": {
              "dirpath": ".",
              "dirrealpath": "",
              "id": "",
              "lookupPaths": [
                "package.json",
                ".package.json"
              ],
              "descriptorPaths": [
                "package.json"
              ],
              "raw": {
                "package.json": {
                  "uid": "github.com/pinf/pinf-loader-secure-js/client",
                  "main": "./sandbox.js",
                  "exports": {
                    "bundles": {
                      "sandbox.js": "./sandbox.js"
                    }
                  }
                }
              },
              "normalized": {
                ".package.json": {},
                "package.json": {
                  "uid": "github.com/pinf/pinf-loader-secure-js/client",
                  "exports": {
                    "bundles": {
                      "sandbox.js": "./sandbox.js"
                    },
                    "main": "./sandbox.js"
                  }
                }
              },
              "combined": {
                "uid": "github.com/pinf/pinf-loader-secure-js/client",
                "exports": {
                  "bundles": {
                    "sandbox.js": "./sandbox.js"
                  },
                  "main": "./sandbox.js"
                }
              },
              "warnings": [],
              "errors": [],
              "memoized": {
                "main": "/sandbox.js",
                "mappings": {
                  "sjcl": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl"
                },
                "dirpath": "."
              }
            },
            "wrapper": "json"
          },
          "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/package.json": {
            "requireId": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/package.json",
            "memoizeId": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/package.json",
            "descriptor": {
              "dirpath": "../node_modules/sjcl",
              "dirrealpath": "../node_modules/sjcl",
              "id": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl",
              "lookupPaths": [
                "../node_modules/sjcl/package.json",
                "../node_modules/sjcl/.package.json"
              ],
              "descriptorPaths": [
                "../node_modules/sjcl/package.json"
              ],
              "raw": {
                "package.json": {
                  "name": "sjcl",
                  "version": "1.0.1",
                  "description": "Stanford Javascript Crypto Library",
                  "main": "sjcl.js",
                  "author": {
                    "name": "bitwiseshiftleft"
                  },
                  "keywords": [
                    "encryption",
                    "high-level",
                    "crypto"
                  ],
                  "repository": {
                    "type": "git",
                    "url": "https://github.com/bitwiseshiftleft/sjcl.git"
                  },
                  "scripts": {
                    "test": "make test"
                  },
                  "engines": {
                    "node": "*"
                  },
                  "readme": "sjcl\n====\n\n[![Build Status](https://travis-ci.org/bitwiseshiftleft/sjcl.png)](https://travis-ci.org/bitwiseshiftleft/sjcl)\n\nStanford Javascript Crypto Library\n\nSecurity Advisories\n===\n* 12.02.2014: the current development version has a paranoia bug in the ecc module. The bug was introduced in commit [ac0b3fe0](https://github.com/bitwiseshiftleft/sjcl/commit/ac0b3fe0) and might affect ecc key generation on platforms without a platform random number generator.\n* \n\nSecurity Contact\n====\nSecurity Mail: sjcl@ovt.me  \nOpenPGP-Key Fingerprint: 0D54 3E52 87B4 EC06 3FA9 0115 72ED A6C7 7AAF 48ED  \nKeyserver: pool.sks-keyservers.net  \n\nDocumentation\n====\nThe documentation is available [here](http://bitwiseshiftleft.github.io/sjcl/doc/)",
                  "readmeFilename": "README.md",
                  "bugs": {
                    "url": "https://github.com/bitwiseshiftleft/sjcl/issues"
                  },
                  "homepage": "https://github.com/bitwiseshiftleft/sjcl",
                  "_id": "sjcl@1.0.1",
                  "_shasum": "e09588578eaa39d872ed5fe903fb6ca177d42647",
                  "_resolved": "git://github.com/bitwiseshiftleft/sjcl.git#b52f843f9e59ee6666cd123b5cacf7954c010f08",
                  "_from": "sjcl@git://github.com/bitwiseshiftleft/sjcl.git#b52f843f9e59ee6666cd123b5cacf7954c010f08"
                }
              },
              "normalized": {
                ".package.json": {
                  "pm": {
                    "install": "npm"
                  },
                  "layout": {
                    "directories": {
                      "dependency": "./node_modules"
                    }
                  }
                },
                "package.json": {
                  "name": "sjcl",
                  "description": "Stanford Javascript Crypto Library",
                  "version": "1.0.1",
                  "locator": {
                    "pointer": "git://github.com/bitwiseshiftleft/sjcl.git#b52f843f9e59ee6666cd123b5cacf7954c010f08"
                  },
                  "homepage": "https://github.com/bitwiseshiftleft/sjcl",
                  "social": {
                    "bugs": {
                      "url": "https://github.com/bitwiseshiftleft/sjcl/issues"
                    }
                  },
                  "repositories": [
                    {
                      "type": "git",
                      "url": "https://github.com/bitwiseshiftleft/sjcl.git"
                    }
                  ],
                  "requirements": {
                    "engines": {
                      "node": "*"
                    }
                  },
                  "exports": {
                    "scripts": {
                      "test": "make test"
                    },
                    "main": "./sjcl.js"
                  },
                  "files": {
                    "readme": "./README.md"
                  },
                  "keywords": [
                    "encryption",
                    "high-level",
                    "crypto"
                  ],
                  "contributors": [
                    {
                      "name": "bitwiseshiftleft"
                    }
                  ],
                  "pm": {
                    "install": "npm"
                  },
                  "layout": {
                    "directories": {
                      "dependency": "./node_modules"
                    }
                  }
                }
              },
              "combined": {
                "name": "sjcl",
                "description": "Stanford Javascript Crypto Library",
                "version": "1.0.1",
                "locator": {
                  "pointer": "git://github.com/bitwiseshiftleft/sjcl.git#b52f843f9e59ee6666cd123b5cacf7954c010f08"
                },
                "homepage": "https://github.com/bitwiseshiftleft/sjcl",
                "social": {
                  "bugs": {
                    "url": "https://github.com/bitwiseshiftleft/sjcl/issues"
                  }
                },
                "repositories": [
                  {
                    "type": "git",
                    "url": "https://github.com/bitwiseshiftleft/sjcl.git"
                  }
                ],
                "requirements": {
                  "engines": {
                    "node": "*"
                  }
                },
                "exports": {
                  "scripts": {
                    "test": "make test"
                  },
                  "main": "./sjcl.js"
                },
                "files": {
                  "readme": "./README.md"
                },
                "keywords": [
                  "encryption",
                  "high-level",
                  "crypto"
                ],
                "contributors": [
                  {
                    "name": "bitwiseshiftleft"
                  }
                ],
                "pm": {
                  "install": "npm"
                },
                "layout": {
                  "directories": {
                    "dependency": "./node_modules"
                  }
                }
              },
              "warnings": [
                [
                  "normalize",
                  "Property '_shasum' was ignored",
                  "descriptor",
                  "package.json"
                ],
                [
                  "normalize",
                  "Property '_resolved' was ignored",
                  "descriptor",
                  "package.json"
                ]
              ],
              "errors": [],
              "memoized": {
                "main": "74aebe51583a1aa6e83b78461af89adfd8bb7cda-sjcl/sjcl.js",
                "dirpath": "../node_modules/sjcl"
              }
            },
            "wrapper": "json"
          }
        },
        "expectExistingModules": {},
        "bundle": {
          "path": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/client/bundles/sandbox.js"
        },
        "warnings": [],
        "errors": [],
        "id": "/sandbox.js"
      }
    },
    "warnings": [],
    "errors": [],
    "exports": {
      "main": "/sandbox.js"
    }
  },
  "#pinf": {
    "status": 200,
    "data": {
      "rootBundlePath": "/playground/2014-07-pinf-for-mozilla-addon-sdk/pinf-for-mozilla-addon-sdk/node_modules/pinf-loader-secure-js/client/bundles/sandbox.js"
    }
  }
}